<head>
    <link rel="icon" href="./resources/milres/editor_icon.ico">
    <title>Rain Editor v0.0.2-dev9</title>
    <link rel="stylesheet" type="text/css" href="./css/scrollbar.css">
</head>

<body oncontextmenu="return false;">
    <div id="res-selectors"></div>

    <div id="main">
        <canvas id="renderer"></canvas>
        <div id="editor">
            <div id="music-progress"></div>
            <div id="rb-buttons">
                <div id="rb-button-pages-container">
                    <div>
                        <div id="meta-edit">编辑谱面元数据</div>
                        <div id="bpm-edit">编辑 BPM 列表</div>
                        <div id="line-edit">轨道编辑</div>
                        <div id="sb-edit">故事板编辑</div>
                        <div id="script-run">运行脚本</div>

                        <!-- <div id="note-edit">编辑 Note</div> -->
                        <!-- <div id="batch-note-edit">批量编辑 Note</div> -->
                        <!-- <div id="batch-event-edit">批量编辑 Event</div> -->
                    </div>
                </div>
            </div>

            <div id="editor-on-preview">
                <div id="editor-on-preview-inner">
                    <canvas id="editor-on-preview-renderer"></canvas>
                </div>
            </div>

            <div id="top-bar">
                <span>自动切换编辑线: </span> <input id="top-bar-editing-auto-lines-checkbox" type="checkbox" class="milckbox" onfocus="this.blur()">
                | <span>自动排序编辑线: </span> <input id="top-bar-editing-autosort-lines-checkbox" type="checkbox" class="milckbox" onfocus="this.blur()">
                | <span>导出类型: </span> <select id="top-bar-export-type-select" class="milbtn" style="display: inline-flex;">
                    <option value="json" selected>json</option>
                    <!-- <option value="js">js</option> -->
                    <option value="zip">zip</option>
                </select> <button class="milbtn" style="display: inline-flex;" onclick="doExport()" onfocus="this.blur()">导出</button>
                </select>
                | <span>显示不可见的线序: </span> <input id="top-bar-show-invisible-lines-checkbox" type="checkbox" class="milckbox" onfocus="this.blur()"> <br>
                <span>节拍线密度(beats/screen): </span> <input id="top-bar-beats-per-scr-inputer" type="number" class="milbtn" style="display: inline-flex;">
                | <span>字节拍线数每节拍: </span> <input id="top-bar-beat-split-inputer" type="number" class="milbtn" style="display: inline-flex;">
                <br> <button class="milbtn" onclick="addPugIn()" onfocus="this.blur()" style="display: inline-flex;">加载插件</button>
                | <span>播放倍速: </span> <input id="top-bar-playback-speed-inputer" type="number" class="milbtn" style="display: inline-flex;" value="1.0" step="0.25">
                | <span>自动粘连事件: </span> <input id="top-bar-auto-attach-checkbox" type="checkbox" class="milckbox" onfocus="this.blur()">
                | <span>全局流速: </span> <input id="top-bar-global-flows-inputer" type="number" class="milbtn" style="display: inline-flex;">
                <span id="auto-backup-label">| 自动备份: </span> <input id="top-bar-auto-backup-checkbox" type="checkbox" class="milckbox" onfocus="this.blur()"> <br>
                <span>全局note缩放: </span> <input id="top-bar-global-note-scale" type="number" class="milbtn" style="display: inline-flex;" value="1.0" stpe="0.1"></input>
                <span>轨道编辑密度: </span> <input id="top-bar-track-edit-lw" type="number" class="milbtn" style="display: inline-flex;" value="1.0" stpe="0.1"></input>
                <br> <br>

                <div id="top-bar-editing-event-type-selector" style="width: 25%; height: 50%; overflow: auto; display: inline-block;" class="milbtn">
                </div>

                <div id="top-bar-editing-event-filter-selector" style="width: 25%; height: 50%; overflow: auto; display: inline-block;" class="milbtn">
                </div>

                <div id="top-bar-editing-new-event-data-selector" style="width: 40%; height: 50%; overflow: auto; display: inline-block;" class="milbtn">
                    <span>新增事件数据</span> <br>
                    <div style="display: none;">
                        <span>事件归属类型: </span> <select id="top-bar-editing-new-event-data-bearer-type-selector" class="milbtn" style="display: inline-flex;">
                            <option value="0">轨道</option>
                            <option value="1">音符</option>
                            <option value="2">故事板</option>
                        </select> <br>
                    </div>
                    <span>事件归属对象: </span> <input id="top-bar-editing-new-event-data-bearer-inputer" class="milbtn" style="display: inline-flex;"> <br>
                    <span>事件类型: </span> <select id="top-bar-editing-new-event-data-type-selector" class="milbtn" style="display: inline-flex;">

                    </select>
                </div>
            </div>

            <div id="rt-bar">
                <button id="back-home" class="milbtn" style="display: inline-flex;">回到首页</button>
                <button id="save" class="milbtn" style="display: inline-flex;">保存</button>
            </div>

            <!-- edit-page 开头的 div 的 id 命名遵循 f"edit-page-{进入这个page的按钮的id}" -->
            <div id="edit-page-meta-edit">
                <div id="edit-page-back-container"></div>
                <div id="edit-page-meta-edit-main"></div>
            </div>

            <div id="edit-page-bpm-edit">
                <div id="edit-page-back-container"></div>
                <div id="edit-page-bpm-edit-main"></div>
                <div id="edit-page-bpm-edit-footer">
                    <div id="edit-page-bpm-edit-footer-add-bpm" class="milbtn" onclick="addNewBPM()">添加 BPM</div>
                </div>
            </div>

            <div id="edit-page-line-edit">
                <div id="edit-page-back-container"></div>
                <div id="edit-page-line-edit-main"></div>
                <div id="edit-page-line-edit-footer">
                    <div id="edit-page-line-edit-footer-add-line" class="milbtn" onclick="addNewLine()">添加轨道</div>
                </div>
            </div>

            <div id="edit-page-sb-edit">
                <div id="edit-page-back-container"></div>
                <div id="edit-page-sb-edit-main"></div>
                <div id="edit-page-sb-edit-footer">
                    <div id="edit-page-sb-edit-footer-add-sb" class="milbtn" onclick="addNewSb()">添加故事板</div>
                </div>
            </div>

            <div id="edit-page-note-edit">
                <div id="edit-page-back-container"></div>
                <div id="edit-page-note-edit-main"></div>
            </div>

            <div id="edit-page-event-edit">
                <div id="edit-page-back-container"></div>
                <div id="edit-page-event-edit-main"></div>
            </div>

            <div id="edit-page-script-run">
                <div id="edit-page-back-container"></div>
                <div id="edit-page-script-run-main"></div>
                <div id="edit-page-script-run-footer">
                    <div id="edit-page-script-run-footer-run" class="milbtn" onclick="runScript()">运行</div>
                </div>
            </div>

            <div id="edit-page-batch-note-edit">
                <div id="edit-page-back-container"></div>
                <div id="edit-page-batch-note-edit-main"></div>
                <div id="edit-page-batch-note-edit-footer">
                    <div id="edit-page-batch-note-edit-footer-apply" class="milbtn" onclick="applyBatchEditNote()">应用</div>
                </div>
            </div>

            <div id="edit-page-batch-event-edit">
                <div id="edit-page-back-container"></div>
                <div id="edit-page-batch-event-edit-main"></div>
                <div id="edit-page-batch-event-edit-footer">
                    <div id="edit-page-batch-event-edit-footer-apply" class="milbtn" onclick="applyBatchEditEvent()">应用</div>
                </div>
            </div>
        </div>
    </div>
    
    <canvas id="msg-renderer"></canvas>

    <svg width="0" height="0" xmlns="http://www.w3.org/2000/svg">
        <filter id="textureLineColorFilter">
            <feColorMatrix type="matrix" values="
                1 0 0 0 0
                0 1 0 0 0
                0 0 1 0 0
                0 0 0 1 0
            " id="colorMatrix"></feColorMatrix>
        </filter>
    </svg>
</body>

<style>
    #res-selectors {
        padding: 0.3em;
        z-index: 3;
        position: absolute;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        background-color: white;
    }

    body {
        margin: 0;
        padding: 0;
        border: 0;
        overflow: hidden;
        font-family: milFont;
    }

    input {
        font-family: milFont;
    }

    #renderer {
        width: 100%;
        height: 100%;
        /* background: linear-gradient(to bottom right, rgb(142, 197, 252), rgb(162, 66, 255)); */
        background-color: gray;
        z-index: 1;
    }

    #editor {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 2;
        background-color: transparent;
    }

    .editor-area-block {
        position: absolute;
        /* border: 1px solid rgb(255, 255, 255); */
    }

    #editor #music-progress audio {
        width: 100%;
        height: 100%;
    }

    #editor #music-progress audio::-webkit-media-controls-time-remaining-display,
    #editor #music-progress audio::-webkit-media-controls-current-time-display {
        display: none;
    }

    .milbtn {
        background: rgb(142, 197, 252);
        display: flex;
        justify-content: center;
        align-items: center;
        border: none;
        border-radius: 0.5em;
        user-select: none;
        font-family: milFont;
        filter: drop-shadow(0 0 0.5em rgba(0, 0, 0, 0.5));
        padding: 0.22em;
        transition: all 0.2s ease-out;
    }

    .milbtn:hover {
        background: rgb(126, 175, 224);
    }

    #rb-button-pages-container,
    #rb-button-pages-container div {
        width: 100%;
        height: 100%;
    }

    #rb-button-pages-container div div {
        position: absolute;
    }

    #editor-on-preview-inner {
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.5);
        backdrop-filter: blur(20px);
    }

    #editor-on-preview-renderer {
        position: absolute;
    }

    #editor div[id^="edit-page-"] {
        padding: 0.2em;
        box-sizing: border-box;
    }

    #editor div[id^="edit-page-"] div[id$="-main"] {
        width: 100%;
        height: calc(95% - 4em);
        overflow: auto;
    }

    #editor div[id^="edit-page-"] div[id$="-footer"]  {
        width: 100%;
        height: 5%;
    }

    #edit-page-bpm-edit-item {
        width: 100%;
        height: 2em;
        display: flex;
        justify-content: center;
        align-items: center;
        user-select: none;
    }

    #edit-page-bpm-edit-item-index-label {
        display: flex;
        justify-content: center;
        align-items: center;
        width: 5%;
        height: 100%;
    }

    #edit-page-bpm-edit-item-itlabel {
        display: flex;
        justify-content: center;
        align-items: center;
        width: 18%;
        height: 100%;
    }

    #edit-page-bpm-edit-item-delete-this,
    #edit-page-line-edit-item-delete-this,
    #edit-page-sb-edit-item-delete-this {
        display: flex;
        justify-content: center;
        align-items: center;
        width: calc(9% - 4px);
        /* height: 100%; */
        background-color: rgba(255, 0, 0, 0.8);
        border-radius: 2em;
        transform: translateX(2px);
    }

    #edit-page-bpm-edit-item-time {
        width: 30%;
        height: 80%;
    }

    #edit-page-bpm-edit-item-bpm {
        width: 20%;
        height: 80%;
    }

    .input-style1 {
        background-color: rgb(142, 197, 252);
        border: 0;
        text-align: center;
        border-radius: 1em;
        color: white;
        transition: 0.2s ease-out all;
    }

    .input-style1:focus {
        background-color: rgb(120, 169, 218);
        /* transform: scale(1.01); */
        outline: none;
        border: 0;
    }

    .input-style1:hover {
        background-color: rgb(120, 169, 218);
        /* transform: scale(1.01); */
    }

    /* #edit-page-bpm-edit-footer {
        display: flex;
        justify-content: center;
        align-items: center;
    } */

    #edit-page-bpm-edit-footer-add-bpm,
    #edit-page-line-edit-footer-add-line,
    #edit-page-sb-edit-footer-add-sb,
    #edit-page-script-run-footer-run,
    #edit-page-batch-note-edit-footer-apply,
    #edit-page-batch-event-edit-footer-apply {
        width: 30%;
        height: 80%;
    }

    #top-bar {
        overflow-y: auto;
        padding: 0.3em;
        line-height: 1.2;
        box-sizing: border-box;
    }

    #rt-bar {
        overflow-y: auto;
        padding: 0.2em;
        box-sizing: border-box;
    }

    .milckbox {
        background-color: rgb(142, 197, 252);
        border: 0;
    }

    #edit-page-script-run-monaco-container {
        position: block;
        width: 100%;
        height: 60%;
    }

    #rb-buttons {
        overflow: auto;
    }

    #res-selectors span {
        animation: loadingAnim 1.5s infinite linear;
        color: rgb(142, 197, 252);
    }

    @keyframes loadingAnim {
        0% {
            filter: hue-rotate(0deg);
            transform: rotate(0deg);
        }
        100% {
            filter: hue-rotate(360deg);
            transform: rotate(360deg);
        }
    }

    #msg-renderer {
        position: absolute;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        background: transparent;
        z-index: 100;
        pointer-events: none;
    }
</style>

<script src="./js/canvas2d_ext.js"></script>
<script src="./js/mil_easing.js"></script>
<script src="./js/2dtransform.js"></script>
<script src="./js/py_light_utils.js"></script>
<script src="./js/jszip/jszip.min.js"></script>
<script src="./js/mildefault_chart.js"></script>
<script src="./js/utils.js"></script>

<script>
    (() => {
        isTranslating = true;
        const orifetch = window.fetch;
        window.fetch = async function(...args) {
            if (args.length >= 1 && args[0].startsWith("/api") && isTranslating) {
                const content = new Blob(new Uint8Array(await pywebview.api.fetchLocalhost(args[0])));
                args[0] = URL.createObjectURL(content);
            }

            return await orifetch(...args);
        }
    })();
</script>

<script>
    /**
     *                    _ooOoo_
     *                   o8888888o
     *                   88" . "88
     *                   (| -_- |)
     *                    O\ = /O
     *                ____/`---'\____
     *              .   ' \\| |// `.
     *               / \\||| : |||// \
     *             / _||||| -:- |||||- \
     *               | | \\\ - /// | |
     *             | \_| ''\---/'' | |
     *              \ .-\__ `-` ___/-. /
     *           ___`. .' /--.--\ `. . __
     *        ."" '< `.___\_<|>_/___.' >'"".
     *       | | : `- \`.;`\ _ /`;.`/ - ` : | |
     *         \ \ `-. \_ __\ /__ _/ .-` / /
     * ======`-.____`-.___\_____/___.-`____.-'======
     *                    `=---='
     *
     * .............................................
     *          佛祖保佑             永无bug
     */

    window.$ = (selector) => document.querySelector(selector);
    window.$$ = (selector) => document.querySelectorAll(selector);
    window.dpr = window.devicePixelRatio || 1;
    const ctx = $("#renderer").getContext("2d");
    const epr = $("#editor-on-preview-renderer").getContext("2d");
    const mctx = $("#msg-renderer").getContext("2d");
    const colorMatrix = $("#colorMatrix");
    var previewing = false;
    var preview_back = false;
    var preview_backtime = 0.0;
    var pyleaving = false;
    const FUCK = 0;
    var onDelete = () => {};
    var doCopyEditing = () => {};
    var doPasteEditing = () => {};
    var copyEditingData = null;
    var msgs = [];
    var disableDeleteWarn = false;

    const spwan_delete_warn = text => `\n这个操作不可逆！\n你真的要删除吗？这个${text}会丢失很久（真的很久！）`;

    const logger = {
        info: (...args) => console.log("[INFO]", ...args),
        warn: (...args) => console.log("[WARN]", ...args),
        error: (...args) => console.log("[ERROR]", ...args)
    };

    const add_res_selector = (div, name, extnames, id, isdir) => {
        const file_input = document.createElement("input");
        file_input.type = "file";
        if (!isdir) {
            file_input.accept = extnames.join(",");
        } else {
            file_input.webkitdirectory = true;
        }
        const label = document.createElement("label");
        label.innerText = name + ": ";
        label.appendChild(file_input);
        div.appendChild(label);
        div.appendChild(document.createElement("br"));
        if (!div.res_selectors) div.res_selectors = {};
        div.res_selectors[id] = file_input;
        return file_input;
    };

    const add_res_getter = (div, btntext, ids, callback) => {
        const button = document.createElement("button");
        button.innerText = btntext;
        div.appendChild(document.createElement("br"));
        div.appendChild(button);
        div.getres = () => {
            const result = {};
            for (const id of ids) {
                const ipt = div.res_selectors[id];
                if (!ipt.webkitdirectory) result[id] = ipt.files[0];
                else {
                    result[id] = {};
                    for (const f of ipt.files) result[id][f.name] = f;
                }
            }
            return result;
        };
        button.onclick = callback;
        return button;
    };

    const loadImage = async url => {
        if (!url) return null;
        const img = new Image();
        img.src = url;
        if (!(await new Promise((res, rej) => {
            img.onload = () => res(true);
            img.onerror = () => res(false);
        }))) return null;
        return img;
    };

    const init_canvas = cv => {
        const onresize = () => {
            cv.width = window.innerWidth * dpr;
            cv.height = window.innerHeight * dpr;
            window.w = window.innerWidth;
            window.h = window.innerHeight;
            cv.getContext("2d").scale(dpr, dpr);

            $("#msg-renderer").width = window.innerWidth;
            $("#msg-renderer").height = window.innerHeight;
            mctx.scale(dpr, dpr);
        };
        window.addEventListener("resize", onresize);
        onresize();
    };


    const loadFont = async (family, url) => {
        let font = new FontFace(family, `url(${url})`);
        document.fonts.add(await font.load());
    };

    const loadJson = async url => {
        const res = await fetch(url);
        return await res.json();
    };

    const loadAudioBuf = async url => {
        const resp = await fetch(url);
        const arrayBuffer = await resp.arrayBuffer();
        const audioBuffer = await config.actx.decodeAudioData(arrayBuffer);
        return audioBuffer;
    };

    const playSound = buf => {
        const source = config.actx.createBufferSource();
        source.buffer = buf;
        source.connect(config.actx.destination);
        source.start();
    };

    const loadAudio = async (url, master) => {
        const buf = await loadAudioBuf(url);
        let source = null;
        let startTime = 0;
        let pauseTime = 0;
        let isPaused = true;

        const _start = offset => {
            if (source) source.stop();
            source = config.actx.createBufferSource();
            source.buffer = buf;
            source.connect(config.actx.destination);
            source.start(0, offset);
            startTime = config.actx.currentTime - offset;

            source.onended = () => {
                if (config.actx.currentTime - startTime >= buf.duration) {
                    isPaused = true;
                    pauseTime = 0;
                }
            };
        };

        const ret = {
            play: () => {
                if (isPaused) {
                    _start(pauseTime);
                    isPaused = false;
                }

                if (!ret.callFromMaster) master.play();
            },
            pause: () => {
                if (!isPaused && source) {
                    source.stop();
                    pauseTime = config.actx.currentTime - startTime;
                    isPaused = true;
                }

                if (!ret.callFromMaster) master.pause();
            },
            get paused() { return isPaused },
            get currentTime() { return isPaused ? pauseTime : config.actx.currentTime - startTime },
            set currentTime(v) {
                v = Math.max(0, Math.min(buf.duration, v));

                if (!isPaused) {
                    _start(v);
                } else {
                    pauseTime = v;
                }

                if (!ret.callFromMaster) master.currentTime = v;
            },
            callFromMaster: false,
            callFromMasterWapper: f => {
                return (...a) => {
                    ret.callFromMaster = true;
                    f(...a);
                    ret.callFromMaster = false;
                };
            }
        };

        return ret;
    };

    const PuginPageCallback = new Map();

    const addPugIn = async () => {
        const file = await window.showOpenFilePicker({ types: [{ description:"JavaScript File", accept: { "application/javascript": [".js"] } }]});
        if (file && confirm("你完全明白你在做什么吗?")) {
            const js = await fetch(URL.createObjectURL(await file[0].getFile())).then(x => x.text());
            with ({
                API: {
                    regButton: (id, text, init, callback) => {
                        const btn = document.createElement("div");
                        btn.innerText = text;
                        btn.id = id;
                        init_rb_button(btn);
                        $("#rb-buttons-page-item").appendChild(btn);

                        const page = document.createElement("div");
                        page.innerHTML = `
                            <div id="edit-page-back-container"></div>
                            <div id="edit-page-${id}-main"></div>
                            <div id="edit-page-${id}-footer">
                        `;
                        page.id = `edit-page-${id}`;
                        $("#editor").appendChild(page);
                        page.classList.add("editor-area-block");
                        init_edit_page(page);

                        init(page);
                        PuginPageCallback.set(id, callback);
                    },
                }
            }) eval(js)
        }
    };

    const history_charts = [];
    var currhistoryi = -1;
    var lastchart = null;
    const updateChartChange = () => {
        ChartUtils.get_es_value_filter_cache.clear();
        config.morebets_cache.clear();
        if (window.pywebview) {
            pywebview.api.onChartChanged();
        }
    };

    const pushMsg = msg => msgs.push({
        msg: msg,
        time: performance.now(),
        y: (msgs.length ? Math.max(...msgs.map(x => x.y + h / 20)) : 0) + h / 80
    });

    const onchartchanged = msg => {
        for (const e of ChartUtils.getAllAnimations()) {
            if (e.endTime.value < e.startTime.value) e.startTime = e.endTime;
        }

        pushMsg(msg);

        const backup = {};

        for (const k in config.chart) {
            if (k !== "editor") backup[k] = config.chart[k];
        }

        const backup_json = JSON.stringify(backup);
        if (lastchart === backup_json) return;
        lastchart = backup_json;

        if ($("#top-bar-auto-backup-checkbox").checked && window.pywebview) {
            pywebview.api.doAutoBackup(backup_json);
        }

        history_charts.length = ++currhistoryi;
        history_charts.push(backup.deepcopy());
        logger.info(`保存了更改, history ${currhistoryi}`);
        config.chart.editor.history.push(msg);
        updateChartChange();
    };

    window.addEventListener("keydown", e => {
        if (history_charts.length === 0) return;
        if (e.key !== "z" || !e.ctrlKey || e.repeat) return;
        if (currhistoryi - 1 < 0) return;
        if (isInputActive(e)) return;

        const backup = history_charts[--currhistoryi].deepcopy();
        for (const k in backup) {
            config.chart[k] = backup[k];
        }
        logger.info(`撤销了更改, 回退到 history ${currhistoryi}`);
        config.chart.editor.history.push("撤销更改");
        pushMsg("撤销");
        updateChartChange();
    });

    window.addEventListener("keydown", e => {
        if (history_charts.length === 0) return;
        if (e.key !== "y" || !e.ctrlKey || e.repeat) return;
        if (currhistoryi + 1 >= history_charts.length) return;
        if (isInputActive(e)) return;

        const backup = history_charts[++currhistoryi].deepcopy();
        for (const k in backup) {
            config.chart[k] = backup[k];
        }
        logger.info(`重做了更改, 回退到 history ${currhistoryi}`);
        config.chart.editor.history.push("重做更改");
        pushMsg("重做");
        updateChartChange();
    });

    const launch_editor = async () => {
        config = $("#res-selectors").getres();

        $("#res-selectors").innerHTML = "<span>Loading...</span>";
        $("#res-selectors").style.display = "flex";
        $("#res-selectors").style.alignItems = "center";
        $("#res-selectors").style.justifyContent = "center";
        $("#res-selectors span").style.fontSize = "5em";

        if (!config.chart) {
            alert("未选择谱面文件, 创建空谱面");
            config.chart = defaultChart.deepcopy();
        } else {
            config.chart = await fetch(URL.createObjectURL(config.chart)).then(res => res.json());
        }

        config.chart.bpms.sort((a, b) => a.time - b.time);

        for (const line of config.chart.lines) {
            line.animations.sort((a, b) => a.startTime.value - b.startTime.value);
        }

        for (const sb of config.chart.storyboards) {
            sb.animations.sort((a, b) => a.startTime.value - b.startTime.value);
        }

        const fake_audio = document.createElement("audio");
        const audiofn = config.audio.name;
        config.audioext = audiofn.includes(".") ? audiofn.split(".").pop() : "mp3";
        fake_audio.src = URL.createObjectURL(config.audio);
        fake_audio.controls = true;
        fake_audio.onfocus = fake_audio.blur;
        // fake_audio.volume = 0.0;
        await new Promise((resolve) => fake_audio.oncanplay = resolve);
        config.actx = new AudioContext();
        config.audio = fake_audio;
        // config.audio = await loadAudio(fake_audio.src, fake_audio);
        // config.fake_audio = new Proxy(fake_audio, {
        //     get: (target, key) => {
        //         if (["currentTime", "paused", "play", "pause"].includes(key)) return config.audio[key];
        //         return target[key];
        //     },
        //     set: (target, key, value) => {
        //         if (key === "currentTime") return Reflect.set(config.audio, key, value);
        //         return Reflect.set(target, key, value);
        //     }
        // });
        // config.fake_audio_ele = fake_audio;

        // fake_audio.addEventListener("timeupdate", config.audio.callFromMasterWapper(e => {
        //     config.audio.currentTime = fake_audio.currentTime;
        // }));

        // fake_audio.addEventListener("pause", config.audio.callFromMasterWapper(e => {
        //     config.audio.pause();
        // }));

        // fake_audio.addEventListener("play", config.audio.callFromMasterWapper(e => {
        //     config.audio.play();
        // }));

        const illu = await loadImage(URL.createObjectURL(config.image));
        config.illu = illu;
        delete config.image;

        config.pause_btn = await loadImage("./resources/milres/buttons/light/pause.png");
        config.line_head = await loadImage("./resources/milres/line_head.png");

        await loadFont("milFont", "./resources/milres/milfont.ttf");
        await loadFont("milFontBold", "./resources/milres/milfont_bold.ttf");

        config.blur_illu = ctx.getBlurImage(config.illu, 0.001);
        config.chart_render_area = 0.75;
        config.combo_text = "EDITOR";
        config.scroll_beat = [1, 4];
        config.eop = {
            beat_per_page: 4,
            beat_spilt: 4,
            bottom_pad: 1 / 2
        };

        $("#top-bar-beats-per-scr-inputer").value = config.eop.beat_per_page;
        $("#top-bar-beats-per-scr-inputer").onchange = () => {
            const newval = parseInt($("#top-bar-beats-per-scr-inputer").value);
            if (!isNaN(newval) && newval > 0) config.eop.beat_per_page = newval;
        };
        $("#top-bar-beat-split-inputer").value = config.eop.beat_spilt;
        $("#top-bar-beat-split-inputer").onchange = () => {
            const newval = parseInt($("#top-bar-beat-split-inputer").value);
            if (!isNaN(newval) && newval > 0) config.eop.beat_spilt = newval;
        };

        config.flow_speed = 1.33;
        config.note_scale = 335 / 185;
        config.note_imgs = {
            tap: await loadImage("./resources/milres/tap.png"),
            tap_double: await loadImage("./resources/milres/tap_double.png"),
            extap: await loadImage("./resources/milres/extap.png"),
            extap_double: await loadImage("./resources/milres/extap_double.png"),
            hold: await loadImage("./resources/milres/hold.png"),
            hold_double: await loadImage("./resources/milres/hold_double.png"),
            exhold: await loadImage("./resources/milres/exhold.png"),
            exhold_double: await loadImage("./resources/milres/exhold_double.png"),
            drag: await loadImage("./resources/milres/drag.png"),
            drag_double: await loadImage("./resources/milres/drag_double.png")
        };
        config.res_meta = await loadJson("./resources/milres/meta.json");
        config.clicksounds = {
            [MIL_CES.EnumNoteType.Hit]: await loadAudioBuf("./resources/milres/editorcs.wav"),
            [MIL_CES.EnumNoteType.Drag]: await loadAudioBuf("./resources/milres/editorcs.wav"),
        };
        config.played_clicksounds = new Set();
        config.morebets_cache = new Map();
        config.max_bpm = 100000;
        config.chart.editor ||= {
            editing: {
                note: [],
                auto: true,
                auto_sort_byx: true,
                event_type: Array.from({ length: 24 }).map((_, i) => i).filter(i => !(i >= 14 && i <= 21)),
                event_edit_filter: {
                    bearer_type: [0, 1, 2],
                    bearer: ["*"]
                },
                new_event: {
                    bearer_type: 0,
                    bearer: 0,
                    type: 0,
                },
                show_invisible_lineidx: true,
                auto_attach_event: true
            },
            history: [],
            editor_version: [0, 0, 1],
        };
        config.global_note_scale = 1.0;
        config.edit_max_track_per_page = 8;
        config.storyboard_res = {};
        config.sharedStoryboardAssets = "./resources/milres/SharedStoryboardAssets";
        // config.i18n_texts = await loadJson("./resources/milres/i18n_texts.json");
        config.i18n_texts = {};

        // for (const path of [
        //     "loader.js",
        //     "editor/editor.main.js",
        // ]) await loadScript(`${monaco_editor}/${path}`);

        // for (const path of [
        //     "editor/editor.main.css",
        // ]) await loadCss(`${monaco_editor}/${path}`);

        for (const i of [
            // { name: "builtin.drag", skin: true },
            // { name: "builtin.hold", skin: true },
            // { name: "builtin.hold_double", skin: true },
            // { name: "builtin.line", skin: true },
            // { name: "builtin.line_head", skin: true },
            // { name: "builtin.line_pixel", skin: true },
            // { name: "builtin.line_vertical", skin: true },
            // { name: "builtin.tap", skin: true },
            // { name: "builtin.tap_double", skin: true },
            // { name: "builtin.drag", skin: true },
            // { name: "builtin.hold", skin: true },
            // { name: "builtin.hold_double", skin: true },
            // { name: "builtin.line", skin: true },
            // { name: "builtin.line_head", skin: true },
            // { name: "builtin.line_pixel", skin: true },
            // { name: "builtin.line_vertical", skin: true },
            // { name: "builtin.tap", skin: true },
            // { name: "builtin.tap_double", skin: true },
            // { name: "builtin.line", skin: true },
            // { name: "builtin.line", skin: true },
            // { name: "builtin.line", skin: true },
            // { name: "builtin.line", skin: true },
            // { name: "builtin.circle", skin: false },
            // { name: "builtin.exhold", skin: false },
            // { name: "builtin.exhold_double", skin: false },
            // { name: "builtin.extap", skin: false },
            // { name: "builtin.extap_double", skin: false },
            // { name: "builtin.half_circle", skin: false },
            // { name: "builtin.hold_active", skin: false },
            // { name: "builtin.rect", skin: false },
            // { name: "builtin.round_rect", skin: false },
            // { name: "builtin.sector", skin: false },
            // { name: "builtin.triangle", skin: false },
            // { name: "builtin.triangle2", skin: false },
        ]) {
            const ss = "./resources/milres/SharedStoryboardAssets";
            const fn = !i.skin ? i.name : `!skin${config.res_meta.sharedStoryboardAssetsSkin}_${i.name}`;
            const img = await loadImage(`${ss}/${fn}`);
            config.storyboard_res[i.name] = img;
            config.storyboard_res[i.name + ".png"] = img;
            config.storyboard_res[i.name + ".jpg"] = img;
            config.storyboard_res[i.name + ".jpeg"] = img;
        }

        config.scripts_meta = await loadJson("./resources/milres/editor_scripts/meta.json");
        config.scripts = {};
        for (const i in config.scripts_meta) {
            config.scripts[i] = await fetch("./resources/milres/editor_scripts/" + config.scripts_meta[i]).then(r => r.text());
        }

        // config.audio.play();

        const getfn = fn => {
            fn = fn.toLowerCase();
            if (fn.endsWith(".png") || fn.endsWith(".jpg") || fn.endsWith(".jpeg")) {
                fn = fn.toLowerCase().split(".").slice(0, -1).join(".");
            }
            return fn;
        };

        const new_sbres = {};
        for (let k in config.sbres) {
            new_sbres[getfn(k)] = config.sbres[k];
        }
        config.sbres = new_sbres;

        for (const sb of config.chart.storyboards) {
            if (sb.type === MIL_CES.EnumStoryboardType.Picture) {
                if (sb.data in config.storyboard_res) continue;
                let imgfn = getfn(sb.data);
                let url = null;

                try {
                    url = URL.createObjectURL(config.sbres[imgfn]);
                } catch (e) {}

                const img = await loadImage(url);
                if (img !== null) {
                    config.storyboard_res[sb.data] = img;
                    logger.info(`加载了故事板资源 ${sb.data}`);
                }
            }
        }

        $("#top-bar-editing-auto-lines-checkbox").checked = config.chart.editor.editing.auto;
        $("#top-bar-editing-auto-lines-checkbox").onchange = () => {
            config.chart.editor.editing.auto = $("#top-bar-editing-auto-lines-checkbox").checked;
        };

        $("#top-bar-editing-autosort-lines-checkbox").checked = config.chart.editor.editing.auto_sort_byx;
        $("#top-bar-editing-autosort-lines-checkbox").onchange = () => {
            config.chart.editor.editing.auto_sort_byx = $("#top-bar-editing-autosort-lines-checkbox").checked;
        };

        $("#top-bar-auto-attach-checkbox").checked = config.chart.editor.editing.auto_attach_event;
        $("#top-bar-auto-attach-checkbox").onchange = () => {
            config.chart.editor.editing.auto_attach_event = $("#top-bar-auto-attach-checkbox").checked;
        };

        $("#top-bar-global-flows-inputer").value = config.flow_speed;
        $("#top-bar-global-flows-inputer").onchange = () => {
            const newval = parseFloat($("#top-bar-global-flows-inputer").value);
            if (!isNaN(newval) && newval > 0) {
                config.flow_speed = newval;
            } else {
                $("#top-bar-global-flows-inputer").value = config.flow_speed;
            }
        };

        $("#top-bar-global-note-scale").value = config.global_note_scale;
        $("#top-bar-global-note-scale").onchange = () => {
            const newval = parseFloat($("#top-bar-global-note-scale").value);
            if (!isNaN(newval) && newval > 0) {
                config.global_note_scale = newval;
            } else {
                $("#top-bar-global-note-scale").value = config.global_note_scale;
            }
        };
        
        $("#top-bar-track-edit-lw").value = config.edit_max_track_per_page;
        $("#top-bar-track-edit-lw").onchange = () => {
            const newval = parseFloat($("#top-bar-track-edit-lw").value);
            if (!isNaN(newval) && newval > 0) {
                config.edit_max_track_per_page = newval;
            } else {
                $("#top-bar-track-edit-lw").value = config.edit_max_track_per_page;
            }
        };

        const eventTypeSelector = $("#top-bar-editing-event-type-selector");
        const eventTypeSelectorLabel = document.createElement("label");
        const eventTypeSelectorAll = document.createElement("botton");
        const eventTypeSelectorDeselect = document.createElement("botton");
        eventTypeSelectorLabel.innerHTML = "编辑事件类型 ";
        eventTypeSelectorAll.innerHTML = "全选";
        eventTypeSelectorAll.classList.add("milbtn");
        eventTypeSelectorAll.style.display = "inline-flex";
        eventTypeSelectorAll.onclick = () => eventTypeSelectorCheckboxs.forEach(x => { x.checked = true; x.onchange(); });
        eventTypeSelectorDeselect.innerHTML = "反选";
        eventTypeSelectorDeselect.classList.add("milbtn");
        eventTypeSelectorDeselect.style.display = "inline-flex";
        eventTypeSelectorDeselect.onclick = () => eventTypeSelectorCheckboxs.forEach(x => x.click());
        eventTypeSelectorAll.style.padding = eventTypeSelectorDeselect.style.padding = "4px";
        eventTypeSelectorDeselect.style.marginLeft = "4px";
        eventTypeSelector.appendChild(eventTypeSelectorLabel);
        eventTypeSelector.appendChild(eventTypeSelectorAll);
        eventTypeSelector.appendChild(eventTypeSelectorDeselect);
        eventTypeSelector.appendChild(document.createElement("br"));
        const eventTypeSelectorCheckboxs = [];        
        for (let i = 0; i < 24; i++) {
            if (14 <= i && i <= 21) continue;
            const name = MIL_CES.EnumAnimationTypeName[i];
            const label = document.createElement("label");
            label.innerHTML = name;
            const checkbox = document.createElement("input");
            checkbox.type = "checkbox";
            checkbox.id = `top-bar-editing-event-type-checkbox-${i}`;
            label.onclick = () => checkbox.click();
            checkbox.checked = config.chart.editor.editing.event_type.includes(i);
            checkbox.onchange = () => {
                if (checkbox.checked) {
                    if (!config.chart.editor.editing.event_type.includes(i)) config.chart.editor.editing.event_type.push(i);
                } else {
                    config.chart.editor.editing.event_type = config.chart.editor.editing.event_type.filter(v => v !== i);
                }
                editing_events_track_map.clear();
            };
            eventTypeSelectorCheckboxs.push(checkbox);
            $("#top-bar-editing-event-type-selector").appendChild(checkbox);
            $("#top-bar-editing-event-type-selector").appendChild(label);
            $("#top-bar-editing-event-type-selector").appendChild(document.createElement("br"));
        }

        const eventFilterSelector = $("#top-bar-editing-event-filter-selector");
        const eventFilterSelectorBearerTypeLabel = document.createElement("label");
        eventFilterSelectorBearerTypeLabel.innerHTML = "事件归属类型";
        eventFilterSelector.appendChild(eventFilterSelectorBearerTypeLabel);
        eventFilterSelector.appendChild(document.createElement("br"));
        for (let i = 0; i < 3; i++) {
            const name = MIL_CES.EnumAnimationBearerTypeTextLong[i];
            const label = document.createElement("label");
            label.innerHTML = name;
            const checkbox = document.createElement("input");
            checkbox.type = "checkbox";
            checkbox.id = `top-bar-editing-event-filter-checkbox-${i}`;
            label.onclick = () => checkbox.click();
            checkbox.checked = config.chart.editor.editing.event_edit_filter.bearer_type.includes(i);
            checkbox.onchange = () => {
                if (checkbox.checked) {
                    if (!config.chart.editor.editing.event_edit_filter.bearer_type.includes(i)) config.chart.editor.editing.event_edit_filter.bearer_type.push(i);
                } else {
                    config.chart.editor.editing.event_edit_filter.bearer_type = config.chart.editor.editing.event_edit_filter.bearer_type.filter(v => v !== i);
                }
                editing_events_track_map.clear();
            };
            eventFilterSelector.appendChild(checkbox);
            eventFilterSelector.appendChild(label);
            eventFilterSelector.appendChild(document.createElement("br"));
        }
        eventFilterSelector.appendChild(document.createElement("br"));
        const eventFilterSelectorBearerLabel = document.createElement("label");
        eventFilterSelectorBearerLabel.innerHTML = "事件归属";
        eventFilterSelector.appendChild(eventFilterSelectorBearerLabel);
        eventFilterSelector.appendChild(document.createElement("br"));
        const eventFilterSelectorBearerInput = document.createElement("textarea");
        eventFilterSelectorBearerInput.id = "top-bar-editing-event-filter-bearer-input";
        eventFilterSelectorBearerInput.placeholder = "每行为一个条件, (*为任意值, n..m为n到m的任意值, n..为n到最大值, ..m为最小值到m的任意值, n为n的值)";
        eventFilterSelectorBearerInput.value = config.chart.editor.editing.event_edit_filter.bearer.join("\n");
        eventFilterSelectorBearerInput.style.width = "100%";
        eventFilterSelectorBearerInput.style.height = "1000%";
        eventFilterSelectorBearerInput.onchange = () => {
            config.chart.editor.editing.event_edit_filter.bearer = eventFilterSelectorBearerInput.value.split("\n");
            editing_events_track_map.clear();
        };
        eventFilterSelector.appendChild(eventFilterSelectorBearerInput);

        const onupdate_editing_new_event_data = () => {
            $("#top-bar-editing-new-event-data-type-selector").innerHTML = `
                <option value="0"${config.chart.editor.editing.new_event.type === 0 ? " selected" : ""}>${MIL_CES.EnumAnimationTypeName[0]}</option>
                <option value="1"${config.chart.editor.editing.new_event.type === 1 ? " selected" : ""}>${MIL_CES.EnumAnimationTypeName[1]}</option>
                <option value="2"${config.chart.editor.editing.new_event.type === 2 ? " selected" : ""}>${MIL_CES.EnumAnimationTypeName[2]}</option>
                <option value="3"${config.chart.editor.editing.new_event.type === 3 ? " selected" : ""}>${MIL_CES.EnumAnimationTypeName[3]}</option>
                <option value="4"${config.chart.editor.editing.new_event.type === 4 ? " selected" : ""}>${MIL_CES.EnumAnimationTypeName[4]}</option>
                <option value="5"${config.chart.editor.editing.new_event.type === 5 ? " selected" : ""}>${MIL_CES.EnumAnimationTypeName[5]}</option>
                <option value="6"${config.chart.editor.editing.new_event.type === 6 ? " selected" : ""}>${MIL_CES.EnumAnimationTypeName[6]}</option>
                <option value="7"${config.chart.editor.editing.new_event.type === 7 ? " selected" : ""}>${MIL_CES.EnumAnimationTypeName[7]}</option>
                <option value="8"${config.chart.editor.editing.new_event.type === 8 ? " selected" : ""}>${MIL_CES.EnumAnimationTypeName[8]}</option>
                <option value="9"${config.chart.editor.editing.new_event.type === 9 ? " selected" : ""}>${MIL_CES.EnumAnimationTypeName[9]}</option>
                <option value="10"${config.chart.editor.editing.new_event.type === 10 ? " selected" : ""}>${MIL_CES.EnumAnimationTypeName[10]}</option>
                <option value="11"${config.chart.editor.editing.new_event.type === 11 ? " selected" : ""}>${MIL_CES.EnumAnimationTypeName[11]}</option>
                <option value="12"${config.chart.editor.editing.new_event.type === 12 ? " selected" : ""}>${MIL_CES.EnumAnimationTypeName[12]}</option>
                <option value="13"${config.chart.editor.editing.new_event.type === 13 ? " selected" : ""}>${MIL_CES.EnumAnimationTypeName[13]}</option>
                <!-- <option value="14"${config.chart.editor.editing.new_event.type === 14 ? " selected" : ""}>${MIL_CES.EnumAnimationTypeName[14]}</option> --!>
                <!-- <option value="15"${config.chart.editor.editing.new_event.type === 15 ? " selected" : ""}>${MIL_CES.EnumAnimationTypeName[15]}</option> --!>
                <!-- <option value="16"${config.chart.editor.editing.new_event.type === 16 ? " selected" : ""}>${MIL_CES.EnumAnimationTypeName[16]}</option> --!>
                <!-- <option value="17"${config.chart.editor.editing.new_event.type === 17 ? " selected" : ""}>${MIL_CES.EnumAnimationTypeName[17]}</option> --!>
                <!-- <option value="18"${config.chart.editor.editing.new_event.type === 18 ? " selected" : ""}>${MIL_CES.EnumAnimationTypeName[18]}</option> --!>
                <!-- <option value="19"${config.chart.editor.editing.new_event.type === 19 ? " selected" : ""}>${MIL_CES.EnumAnimationTypeName[19]}</option> --!>
                <!-- <option value="20"${config.chart.editor.editing.new_event.type === 20 ? " selected" : ""}>${MIL_CES.EnumAnimationTypeName[20]}</option> --!>
                <!-- <option value="21"${config.chart.editor.editing.new_event.type === 21 ? " selected" : ""}>${MIL_CES.EnumAnimationTypeName[21]}</option> --!>
                <option value="22"${config.chart.editor.editing.new_event.type === 22 ? " selected" : ""}>${MIL_CES.EnumAnimationTypeName[22]}</option>
                <option value="23"${config.chart.editor.editing.new_event.type === 23 ? " selected" : ""}>${MIL_CES.EnumAnimationTypeName[23]}</option>
            `;
            $("#top-bar-editing-new-event-data-bearer-type-selector").querySelectorAll("option").forEach(o => {
                if (o.value === config.chart.editor.editing.new_event.bearer_type) o.setAttribute("selected", "selected");
            });
            $("#top-bar-editing-new-event-data-bearer-inputer").value = config.chart.editor.editing.new_event.bearer;
        };

        onupdate_editing_new_event_data();
        $("#top-bar-editing-new-event-data-type-selector").onchange = () => {
            const newval = parseInt($("#top-bar-editing-new-event-data-type-selector").value);
            if (!isNaN(newval) && 0 <= newval && newval < 24) {
                config.chart.editor.editing.new_event.type = newval;
                onupdate_editing_new_event_data();
            }
        };
        $("#top-bar-editing-new-event-data-bearer-type-selector").onchange = () => {
            const newval = parseInt($("#top-bar-editing-new-event-data-bearer-type-selector").value);
            if (!isNaN(newval) && 0 <= newval && newval < 3) {
                config.chart.editor.editing.new_event.bearer_type = newval;
                onupdate_editing_new_event_data();
            }
        };
        $("#top-bar-editing-new-event-data-bearer-inputer").onchange = () => {
            const newval = parseInt($("#top-bar-editing-new-event-data-bearer-inputer").value);
            if (!isNaN(newval) && newval >= 0) {
                config.chart.editor.editing.new_event.bearer = newval;
                onupdate_editing_new_event_data();
            }
        };

        $("#top-bar-show-invisible-lines-checkbox").checked = config.chart.editor.show_invisible_lines;
        $("#top-bar-show-invisible-lines-checkbox").onchange = () => {
            config.chart.editor.show_invisible_lines = $("#top-bar-show-invisible-lines-checkbox").checked;
        };

        config.event_icons = [];
        for (let i = 0; i < 24; i++) {
            const img = await loadImage(`./resources/milres/editor_event_icons/${i}.png`);
            config.event_icons.push(img);
        }

        $("#main").style.display = "block";
        init_canvas($("#renderer"));
        $("#editor #music-progress").appendChild(fake_audio);
        ChartUtils.optIdx();
        requestAnimationFrame(render);
        onchartchanged("加载谱面");
        console.log(config);

        $("#res-selectors").style.transition = "all 0.5s ease-out";
        $("#res-selectors").clientWidth; // force reflow
        $("#res-selectors").style.opacity = "1.0";
        $("#res-selectors").clientWidth; // force reflow
        $("#res-selectors").style.opacity = "0.0";
        $("#res-selectors").ontransitionend = () => $("#res-selectors").style.display = "none"

        $("#top-bar-playback-speed-inputer").onchange = () => {
            config.audio.playbackRate = parseFloat($("#top-bar-playback-speed-inputer").value);
        };
    };

    const get_difficulty_fn = () => {
        const name = config.chart.meta.difficulty_name;
        const value = config.chart.meta.difficulty;
        const add_symbol = value % 1.0 !== 0.0;
        return `${name} ${Math.floor(value)}${add_symbol ? "+" : ""}`;
    };

    const enumerate = arr => {
        let i = 0;
        return {
            [Symbol.iterator]() {
                return {
                    next() {
                        return { value: [i, arr[i++]], done: i > arr.length };
                    }
                }
            }
        }
    };

    const setColorMatrix = (r, g, b) => {
        colorMatrix.setAttribute("values", `${r} 0 0 0 0 0 ${g} 0 0 0 0 0 ${b} 0 0 0 0 0 1 0`);
    }

    const applyCtxColorFilter = (ctx, r, g, b) => {
        if (r !== 1.0 || g !== 1.0 || b !== 1.0) {
            setColorMatrix(r, g, b);
            ctx.filter = "url(#textureLineColorFilter)";
        }
    };

    const fmtBeatStr = b => `${Math.floor(b)}:${Math.floor(b % 1.0 * config.eop.beat_spilt)}/${config.eop.beat_spilt}`;
    var editing_note_lines_area = [0, 0, 0, 0];
    var editing_note_lines_remove_areas = [];
    var editing_note_lines_note_areas = [];
    var editing_note_lines_get_index_from_x = x => -1;
    var editing_note_lines_get_beat_from_y = y => [0, 0, 1];
    var lines_pos = new Map();
    var notes_rects = [];
    var display_eop = false;
    var editing_note_dx = 0;
    var editing_events_track_map = new Map();
    var editing_events_areas = [];
    var editing_event_lines_area = [0, 0];
    var editing_event_dx = 0;
    var editing_event_lines_get_index_from_x = x => -1;
    var edtracks = [];

    const render = () => {
        const fps = 1000 / (performance.now() - render.lastCall);
        render.lastCall = performance.now();
        lines_pos.clear();
        notes_rects.length = 0;

        const chart = config.chart;
        const chart_render_area = config.chart_render_area;
        const now_t = config.audio.currentTime - config.chart.meta.offset;
        const now_beat = ChartUtils.sec2beat(now_t);

        const set_editor_area = (name, rect, mult = true) => {
            if (mult) rect = [rect[0] * w, rect[1] * h, rect[2] * w, rect[3] * h];
            const ele = $(`#editor #${name}`);
            ele.style.left = `${rect[0]}px`;
            ele.style.top   = `${rect[1]}px`;
            ele.style.width = `${rect[2]}px`;
            ele.style.height = `${rect[3]}px`;

            if (ele.nodeName === "CANVAS") {
                ele.width = rect[2] * dpr;
                ele.height = rect[3] * dpr;

                if (!ele.lastSize || ele.lastSize[0] !== rect[2] || ele.lastSize[1] !== rect[3]) {
                    ele.lastSize = [rect[2], rect[3]];
                }
            }
        };

        const grid_place_rb_buttons_page = page => {
            const btn_page_size = [2, 6];
            let i = 0;

            page.childNodes.forEach(btn => {
                if (btn.nodeName !== "DIV") return;
                const aw = w * (1.0 - chart_render_area);
                const ah = h * chart_render_area;

                const pad = (aw + ah) * 0.012;
                const width = (aw - pad * (btn_page_size[0] + 1)) / btn_page_size[0] * dpr;
                const height = (ah - pad * (btn_page_size[1] + 1)) / btn_page_size[1] * dpr;

                btn.style.width = width + "px";
                btn.style.height = height + "px";

                const col = i % btn_page_size[0];
                const row = Math.floor(i / btn_page_size[0]);

                btn.style.left = (width + pad) * col + pad + "px";
                btn.style.top = (height + pad) * row + pad + "px";

                i++;
            });
        };

        ctx.clear();

        { // render chart
            const aw = chart_render_area * w;
            const ah = chart_render_area * h;
            const line_id_render_items = [];

            const render_storyboards = sbs => {
                with (ChartUtils) { with (MIL_CES) {
                    for (const sb of sbs) {
                        const sbEventFilter = {
                            bearer_type: EnumAnimationBearerType.StoryBoard,
                            bearer: sb.index
                        };

                        const sbPos = normalized_to_cvs(...normalize_to_screen(
                            get_es_value(sb.animations, now_beat, 0, EnumAnimationType.PositionX, sbEventFilter),
                            get_es_value(sb.animations, now_beat, 0, EnumAnimationType.PositionY, sbEventFilter),
                        ), aw, ah);

                        const sbRelPos = normalized_to_cvs(...normalize_to_center(
                            get_es_value(sb.animations, now_beat, 0, EnumAnimationType.RelativeX, sbEventFilter),
                            get_es_value(sb.animations, now_beat, 0, EnumAnimationType.RelativeY, sbEventFilter),
                        ), aw, ah);

                        const sbRotation = get_es_value(sb.animations, now_beat, 0, EnumAnimationType.Rotation, sbEventFilter);
                        const sbSize = get_es_value(sb.animations, now_beat, 1, EnumAnimationType.Size, sbEventFilter);
                        const sbW = get_es_value(sb.animations, now_beat, 1, EnumAnimationType.StoryBoardWidth, sbEventFilter);
                        const sbH = get_es_value(sb.animations, now_beat, 1, EnumAnimationType.StoryBoardHeight, sbEventFilter);
                        const sbAlpha = get_es_value(sb.animations, now_beat, 0, EnumAnimationType.Transparency, sbEventFilter);
                        const sbColor = get_es_value(sb.animations, now_beat, [1, 1, 1, 1], EnumAnimationType.Color, sbEventFilter);

                        const sbLT = [
                            get_es_value(sb.animations, now_beat, -0.5, EnumAnimationType.StoryBoardLeftTopX, sbEventFilter),
                            get_es_value(sb.animations, now_beat, -0.5, EnumAnimationType.StoryBoardLeftTopY, sbEventFilter),
                        ];

                        const sbRT = [
                            get_es_value(sb.animations, now_beat, 0.5, EnumAnimationType.StoryBoardRightTopX, sbEventFilter),
                            get_es_value(sb.animations, now_beat, -0.5, EnumAnimationType.StoryBoardRightTopY, sbEventFilter),
                        ];

                        const sbLB = [
                            get_es_value(sb.animations, now_beat, -0.5, EnumAnimationType.StoryBoardLeftBottomX, sbEventFilter),
                            get_es_value(sb.animations, now_beat, 0.5, EnumAnimationType.StoryBoardLeftBottomY, sbEventFilter),
                        ];

                        const sbRB = [
                            get_es_value(sb.animations, now_beat, 0.5, EnumAnimationType.StoryBoardRightBottomX, sbEventFilter),
                            get_es_value(sb.animations, now_beat, 0.5, EnumAnimationType.StoryBoardRightBottomY, sbEventFilter),
                        ]

                        const sbMergedPos = [
                            sbPos[0] + sbRelPos[0],
                            sbPos[1] + sbRelPos[1],
                        ];

                        ctx.save();
                        ctx.translate(...sbMergedPos);
                        ctx.rotate(sbRotation * Math.PI / 180);
                        ctx.scale(sbSize, sbSize);
                        ctx.scale(sbW, sbH);

                        ctx.globalAlpha *= Utils.fixorp(sbAlpha * sbColor[3]);

                        if (sb.type === MIL_CES.EnumStoryboardType.Text) {
                            let text = sb.data;

                            if (text.startsWith("@i18n")) {
                                text = (config.i18n_texts[config.res_meta.i18nChose] || {})[text.substring(6)];
                                if (text === void 0) text = sb.data;
                            }

                            ctx.drawTextEx(
                                text,
                                0.0, 0.0,
                                `${(aw + ah) / 40}px milFont`,
                                `rgb(${sbColor.slice(0, 3).map(x => x * 0xff).join(",")})`, "center", "middle"
                            );
                        } else if (sb.type === MIL_CES.EnumStoryboardType.Picture) {
                            const texture = config.storyboard_res[sb.data];
                            if (texture) {
                                const width = texture.width / MIL_SCRSIZE[0] * w;
                                const height = width / texture.width * texture.height;

                                ctx.save();
                                applyCtxColorFilter(ctx, ...sbColor);
                                ctx.scale(width, height);
                                ctx.drawImage(texture, -0.5, -0.5, 1.0, 1.0);
                                // ctx.drawImage4PTransformed(
                                //     texture,
                                //     ...sbLT, ...sbRT, ...sbLB, ...sbRB
                                // );
                                ctx.restore();
                            }
                        } else if (sb.type === MIL_CES.EnumStoryboardType.Mesh) {

                        }

                        ctx.restore();
                    }
                }}
            };

            ctx.save();
            ctx.translate(0, h - ah);
            ctx.beginPath();
            ctx.rect(0, 0, aw, ah);
            ctx.clip();

            ctx.drawCoverFullScreenImage(config.blur_illu, aw, ah);

            render_storyboards(chart.storyboards.filter(sb => sb.layer === MIL_CES.EnumLayer.Background));

            ctx.fillRectEx(0, 0, aw, ah, `rgba(0, 0, 0, ${chart.meta.background_dim})`);

            let combo = 0.0;
            let all_combo_count = config.chart.lines.reduce((acc, line) => acc + line.notes.reduce((acc, note) => acc + (note.isFake ? 0 : (note.ishold ? 2 : 1)), 0), 0);

            if (config.chart.editor.editing.auto) {
                config.chart.editor.editing.note.length = 0;
            }

            render_storyboards(chart.storyboards.filter(sb => sb.layer === MIL_CES.EnumLayer.Normal));

            with (ChartUtils) { with (MIL_CES) {
                for (const line of chart.lines) {
                    const lineEventFilter = {
                        bearer_type: EnumAnimationBearerType.Line,
                        bearer: line.index
                    };

                    const linePos = normalized_to_cvs(...normalize_to_screen(
                        get_es_value(line.animations, now_beat, 0, EnumAnimationType.PositionX, lineEventFilter),
                        get_es_value(line.animations, now_beat, -350, EnumAnimationType.PositionY, lineEventFilter),
                    ), aw, ah);

                    const lineAlpha = get_es_value(line.animations, now_beat, 1, EnumAnimationType.Transparency, lineEventFilter);
                    const lineWholeAlpha = get_es_value(line.animations, now_beat, 1, EnumAnimationType.WholeTransparency, lineEventFilter);
                    const lineSize = get_es_value(line.animations, now_beat, 1, EnumAnimationType.Size, lineEventFilter) * config.global_note_scale;
                    const lineRotation = get_es_value(line.animations, now_beat, 90, EnumAnimationType.Rotation, lineEventFilter);
                    const lineFlowSpeed = get_es_value(line.animations, now_beat, 1, EnumAnimationType.FlowSpeed, lineEventFilter);
                    const lineRelPos = normalized_to_cvs(...normalize_to_center(
                        get_es_value(line.animations, now_beat, 0, EnumAnimationType.RelativeX, lineEventFilter),
                        get_es_value(line.animations, now_beat, 0, EnumAnimationType.RelativeY, lineEventFilter),
                    ), aw, ah);
                    const lineBodyAlpha = get_es_value(line.animations, now_beat, 1, EnumAnimationType.LineBodyTransparency, lineEventFilter);
                    const lineHeadAlpha = get_es_value(line.animations, now_beat, 1, EnumAnimationType.LineHeadTransparency, lineEventFilter);
                    const lineColor = get_es_value(line.animations, now_beat, [1, 1, 1, 1], EnumAnimationType.Color, lineEventFilter);
                    const lineVisibleArea = get_es_value(line.animations, now_beat, NaN, EnumAnimationType.VisibleArea, lineEventFilter);

                    const lineMergedPos = [
                        linePos[0] + lineRelPos[0],
                        linePos[1] + lineRelPos[1],
                    ];

                    lines_pos.set(line.index, lineMergedPos);

                    const lineHeadSize = (aw + ah) * MIL_LINE_HEAD_SIZE * lineSize;
                    const lineHeadBorder = (aw + ah) * MIL_LINE_HEAD_BORDER * lineSize;

                    if (lineSize > 0.0) {
                        ctx.save();
                        applyCtxColorFilter(ctx, ...lineColor);
                        const headAlpha = Utils.fixorp(lineAlpha * lineHeadAlpha * lineColor[3]);
                        ctx.drawAlphaImage(
                            config.line_head,
                            lineMergedPos[0] - lineHeadSize / 2,
                            lineMergedPos[1] - lineHeadSize / 2,
                            lineHeadSize, lineHeadSize,
                            headAlpha
                        );
                        ctx.restore();

                        line_id_render_items.push([lineMergedPos, headAlpha, line.index]);

                        if (config.chart.editor.editing.auto &&
                            headAlpha > 0.0 &&
                            0 <= lineMergedPos[0] && lineMergedPos[0] <= aw &&
                            0 <= lineMergedPos[1] && lineMergedPos[1] <= ah) {
                            config.chart.editor.editing.note.push(line.index);
                        }

                        const bodyPoint = Utils.rotate_point(...lineMergedPos, lineRotation + 180, (aw + ah) * 5);

                        ctx.save();
                        ctx.beginPath();
                        ctx.rect(0, 0, aw, ah);
                        ctx.arc(...lineMergedPos, Math.max(lineHeadSize / 2 - 1.0, 0.0), 0, 2 * Math.PI);
                        ctx.clip(); // 不知道为什么要 clip 两次。。
                        ctx.clip("evenodd");
                        ctx.drawLineEx(
                            ...lineMergedPos, ...bodyPoint,
                            lineHeadBorder * 0.75,
                            `rgba(255, 255, 255, ${Utils.fixorp(lineAlpha * lineBodyAlpha) * 0.8})`
                        );
                        ctx.restore();
                    }

                    const lineFp = get_fp(line.animations, now_beat, lineEventFilter);

                    const noteAnimSet = new Set();
                    const hasAnimationGroup = [];
                    const noAnimationGroup = [];

                    for (const animation of line.animations) {
                        if (animation.bearer_type === EnumAnimationBearerType.Note) noteAnimSet.add(animation.bearer);
                    }

                    for (const note of line.notes) {
                        if (noteAnimSet.has(note.index)) hasAnimationGroup.push(note);
                        else noAnimationGroup.push(note);
                    }

                    for (const note_group of [
                        { notes: hasAnimationGroup, can_break: false },
                        { notes: noAnimationGroup, can_break: true }
                    ]) {
                        for (const note of note_group.notes) {
                            const noteClicked = note.time.value <= now_beat;

                            if (noteClicked && !config.played_clicksounds.has(note.index)) {
                                config.played_clicksounds.add(note.index);

                                if (!config.audio.paused && !note.isFake) playSound(config.clicksounds[note.type]);
                            } else if (!noteClicked && config.played_clicksounds.has(note.index)) {
                                config.played_clicksounds.delete(note.index);
                            }
                            
                            if (note.ishold && noteClicked && !note.isFake) combo++;

                            if ((!note.ishold && noteClicked) ||
                                (note.ishold && note.endTime.sec < now_t)) {
                                if (!note.isFake) combo++;

                                if (!note.ishold || (note.ishold && note.endTime.sec + MIL_HOLD_DISAPPEAR_TIME < now_t)) continue;
                            }

                            const noteEventFilter = {
                                bearer_type: EnumAnimationBearerType.Note,
                                bearer: note.index
                            };
                            const noteStartFp = get_fp(line.animations, note.time.value, lineEventFilter);
                            const noteFlowSpeed = lineFlowSpeed * get_es_value(line.animations, now_beat, 1, EnumAnimationType.FlowSpeed, noteEventFilter) * lineSize;
                            const noteFpMult = MIL_SPEED_UNIT / MIL_SCRSIZE[1] * ah * config.flow_speed * noteFlowSpeed / config.global_note_scale;
                            const rawNoteFp = noteStartFp - lineFp;
                            const noteFp = rawNoteFp * noteFpMult;
                            const noteWidth = (aw + ah) * MIL_NOTE_SIZE * config.note_scale * lineSize * get_es_value(line.animations, now_beat, 1, EnumAnimationType.Size, noteEventFilter);
                            const noteRelPos = normalized_to_cvs(...normalize_to_center(
                                get_es_value(line.animations, now_beat, 0, EnumAnimationType.RelativeX, noteEventFilter),
                                get_es_value(line.animations, now_beat, 0, EnumAnimationType.RelativeY, noteEventFilter),
                            ), aw, ah);
                            const noteEventPos = normalized_to_cvs(...normalize_to_center(
                                get_es_value(line.animations, now_beat, NaN, EnumAnimationType.PositionX, noteEventFilter),
                                get_es_value(line.animations, now_beat, NaN, EnumAnimationType.PositionY, noteEventFilter),
                            ), aw, ah);

                            const [notePos, transform] = get_note_position(
                                note, now_beat,
                                noteFp, noteEventPos, noteRelPos,
                                lineMergedPos, lineRotation
                            );

                            const transformedPos = transform.getPoint(...notePos);

                            const noteIm = config.note_imgs[note.resname];
                            const noteRHeight = noteWidth / noteIm.width * noteIm.height;

                            if (note_group.can_break && !py_light_utils_exports.pointInScreen(
                                [transformedPos[0] + noteWidth, transformedPos[1] + noteRHeight],
                                aw + noteWidth * 2, ah + noteRHeight * 2
                            ) && (
                                Utils.lineLength(aw / 2, ah / 2, ...transform.getPoint(notePos[0], notePos[1] - 1)) -
                                Utils.lineLength(aw / 2, ah / 2, ...transformedPos) > 0.0
                            )) break;

                            if (!isNaN(lineVisibleArea) && noteFp > lineVisibleArea / MIL_SCRSIZE[1] * ah) {
                                if (note_group.can_break) break;
                                continue;
                            }

                            let noteColor = get_es_value(line.animations, now_beat, [1, 1, 1, 1], EnumAnimationType.Color, noteEventFilter);
                            const noteAlpha = Utils.fixorp(lineWholeAlpha * get_es_value(line.animations, now_beat, 1, EnumAnimationType.Transparency, noteEventFilter) * noteColor[3] * (1.0 - Utils.fixorp((now_t - note.endTime.sec) / MIL_HOLD_DISAPPEAR_TIME)));
                            const noteRotation = -90 - get_es_value(line.animations, now_beat, 0, EnumAnimationType.Rotation, noteEventFilter);

                            if (noteAlpha <= 0.0 || noteWidth <= 0.0) continue;

                            let noteHeight, noteRect;
                            let holdLength, atlas, headLength, tailLength, bodyLength, holdTotalLength;
                            if (!note.ishold) {
                                noteHeight = noteWidth / noteIm.width * noteIm.height;
                                noteRect = transform.getCRectPoints(...notePos, noteWidth, noteHeight);
                            } else {
                                const noteEndFp = get_fp(line.animations, note.endTime.value, lineEventFilter);
                                holdLength = (noteEndFp - noteStartFp + Math.min(0.0, rawNoteFp)) * noteFpMult;
                                atlas = config.res_meta[note.morebets ? "holdDoubleAtlas" : "holdAtlas"];
                                headLength = tailLength = noteWidth / 2;
                                bodyLength = Math.max(holdLength, 0.0);

                                holdTotalLength = headLength + bodyLength + tailLength;
                                noteRect = transform.getCRectPoints(notePos[0], notePos[1] - holdTotalLength / 2 + headLength, noteWidth, holdTotalLength);
                            }

                            if (!py_light_utils_exports.polygonInScreen(aw, ah, noteRect)) continue;

                            notes_rects.push([note.index, noteRect]);
                            ctx.save();
                            ctx.translate(...lineMergedPos);
                            ctx.rotate((lineRotation - 90) * Math.PI / 180);
                            if (note.index === editing_note || boxingNoteIdxs.includes(note.index)) noteColor = [0.0, noteColor[1], 0.0, noteColor[3]];
                            applyCtxColorFilter(ctx, ...noteColor);

                            if (!config.chart.editor.editing.note.includes(line.index)) config.chart.editor.editing.note.push(line.index);

                            if (!note.ishold) {
                                ctx.drawRotateImage(
                                    noteIm,
                                    ...notePos,
                                    noteWidth, noteHeight,
                                    noteRotation, noteAlpha
                                );
                            } else {
                                ctx.drawAnchorWCenterRotateImage(
                                    ctx.createTempClip(
                                        noteIm, atlas,
                                        noteWidth,
                                        headLength, bodyLength, tailLength
                                    ),
                                    ...notePos,
                                    holdTotalLength, noteWidth,
                                    noteRotation, noteAlpha,
                                    -headLength
                                );
                            }

                            ctx.restore();
                        }
                    }
                }
            }}

            render_storyboards(chart.storyboards.filter(sb => sb.layer === MIL_CES.EnumLayer.Foreground));

            const line_id_render_items_map = new Map();
            line_id_render_items.forEach(i => {
                const p = i[0][0] + "/" + i[0][1];
                if (!line_id_render_items_map.has(p)) line_id_render_items_map.set(p, []);
                line_id_render_items_map.get(p).push(i);
            });
            line_id_render_items_map.forEach((v, k) => {
                const maxalpha = Math.max(...v.map(i => i[1]));
                const pos = v[0][0];
                const idxs = v.filter(i => config.chart.editor.show_invisible_lines || i[1] > 0.0).map(i => i[2]);
                ctx.drawTextEx(
                    `${idxs.length === 1 ? idxs[0] : (idxs.length === 2 ? `${idxs[0]},${idxs[1]}` : `${idxs[0]}..${idxs[idxs.length - 1]}`)}`,
                    ...pos, `${(aw + ah) / 100}px milFont`,
                    `rgba(255, 255, 255, ${config.chart.editor.show_invisible_lines ? 1.0 : maxalpha})`, "center", "middle"
                );
            });

            ctx.drawAlphaImage(
                config.pause_btn,
                0.0187 * (aw + ah),
                0.0187 * (aw + ah),
                0.026 * (aw + ah),
                0.026 * (aw + ah),
                0.4
            );

            ctx.drawTextEx(
                chart.meta.name,
                aw * 0.0984375,
                0.0187 * (aw + ah),
                `${(aw + ah) / 77}px milFont`,
                "white", "left", "top"
            );

            ctx.drawTextEx(
                get_difficulty_fn(),
                aw * 0.0984375,
                (106 / 1080) * ah,
                `${(aw + ah) / 105}px milFont`,
                "rgba(255, 255, 255, 0.7)", "left", "top"
            );

            ctx.drawTextEx(
                config.combo_text,
                aw * 0.5,
                0.017 * (aw + ah),
                `${(aw + ah) / 79}px milFont`,
                "white", "center", "top"
            );

            ctx.drawTextEx(
                `${combo}`,
                aw * 0.5,
                (128 / 1080) * ah,
                `${(aw + ah) / 60}px milFont`,
                "white", "center", "middle"
            );

            const score = combo / all_combo_count * 1010000;
            ctx.drawTextEx(
                Math.round(score).toString().padStart(7, "0"),
                aw * 0.9734375,
                0.016 * (aw + ah),
                `${(aw + ah) / 58}px milFont`,
                "white", "right", "top"
            );

            const acc = 100.0;
            ctx.drawTextEx(
                `${acc.toFixed(2)}%`,
                aw * 0.9734375,
                (107 / 1080) * ah,
                `${(aw + ah) / 75}px milFont`,
                "rgba(255, 255, 255, 0.7)", "right", "top"
            );

            ctx.restore();
        }

        const music_progress_h = (1 - chart_render_area) / 4
        set_editor_area("music-progress", [
            chart_render_area, 1 - chart_render_area - music_progress_h,
            1 - chart_render_area, music_progress_h,
        ]);

        set_editor_area("rt-bar", [
            chart_render_area, 0,
            1 - chart_render_area, 1 - chart_render_area - music_progress_h,
        ]);
        
        const rb_btns_rect = [
            chart_render_area, 1 - chart_render_area,
            1 - chart_render_area, chart_render_area,
        ];
        set_editor_area("rb-buttons", rb_btns_rect);
        edit_pages.forEach(ele => set_editor_area(ele.id, rb_btns_rect));

        $$("#rb-button-pages-container div").forEach(page => grid_place_rb_buttons_page(page));

        set_editor_area("editor-on-preview", [
            0, 1 - chart_render_area,
            chart_render_area, chart_render_area,
        ]);

        display_eop = !previewing;
        $("#editor-on-preview-inner").style.display = display_eop ? "block" : "none";
        set_editor_area("editor-on-preview-renderer", [
            0, 0,
            chart_render_area, chart_render_area,
        ]);

        set_editor_area("top-bar", [
            0, 0,
            chart_render_area, 1 - chart_render_area,
        ]);

        if (display_eop) {
            const aw = chart_render_area * w;
            const ah = chart_render_area * h;

            if (config.chart.editor.editing.auto_sort_byx) {
                config.chart.editor.editing.note.sortbykey(l => lines_pos.get(l)[0]);
            }

            epr.clear();
            epr.reset(); // resize 的时候 scale 没用, 不知道为什么
            epr.scale(dpr, dpr);

            {
                const gety = b => (ah - (b - now_beat) / config.eop.beat_per_page * ah - ah / 10);
                const getbeat = y => (ah - (y + ah / 10)) * config.eop.beat_per_page / ah + now_beat;
                const drawBeatText = (b, text, bg, fg, x, wmult=1.0) => {
                    const y = gety(b);
                    const curr_beat_rect_size = [
                        aw * 0.08 * wmult,
                        aw * 0.03
                    ];
                    const curr_beat_rect = [
                        x, y - curr_beat_rect_size[1] / 2,
                        ...curr_beat_rect_size,
                    ];
                    epr.roundRectEx(
                        ...curr_beat_rect,
                        curr_beat_rect_size[1] / 2,
                        bg
                    );
                    epr.drawTextEx(
                        text,
                        curr_beat_rect[0] + curr_beat_rect_size[0] / 2,
                        curr_beat_rect[1] + curr_beat_rect_size[1] / 2,
                        `${(aw + ah) / 90}px milFont`,
                        fg, "center", "middle"
                    );
                    return [curr_beat_rect, curr_beat_rect_size];
                };

                let curr_draw_beat = Math.floor(now_beat) - 1;
                let i = 0;
                while (true) {
                    const curr_beat_y = gety(curr_draw_beat);

                    epr.drawLineEx(
                        0, curr_beat_y,
                        aw, curr_beat_y,
                        ah / (i % config.eop.beat_spilt === 0 ? 200 : 250),
                        i % config.eop.beat_spilt === 0 ? "rgba(255, 255, 255, 1.0)" : "rgba(255, 255, 255, 0.4)"
                    );

                    if (i % config.eop.beat_spilt === 0) {
                        drawBeatText(
                            curr_draw_beat,
                            `${Math.floor(curr_draw_beat)}`,
                            "rgba(255, 255, 255, 0.95)", "rgba(0, 0, 0, 0.8)",
                            aw * 0.025, 0.7
                        );
                    }

                    if (curr_beat_y < 0) break;

                    curr_draw_beat += 1 / config.eop.beat_spilt;
                    i++;
                }

                const pad_y = gety(now_beat);

                epr.drawLineEx(
                    0, pad_y,
                    aw, pad_y,
                    ah / 200,
                    "rgb(142, 197, 252)"
                );

                const [curr_beat_rect, curr_beat_rect_size] = drawBeatText(
                    now_beat,
                    fmtBeatStr(now_beat),
                    "rgb(142, 197, 252)", "rgba(255, 255, 255, 0.9)",
                    aw * 0.02
                );

                const edit_area = [
                    curr_beat_rect[0] + curr_beat_rect_size[0],
                    aw
                ];

                { // note 编辑
                    epr.save();
                    epr.beginPath();
                    epr.rect(edit_area[0], 0, (edit_area[1] - edit_area[0]) / 2, ah);
                    epr.clip();

                    const editing_lines = config.chart.editor.editing.note.slice();
                    const track_width = (edit_area[1] - edit_area[0]) / 2 / config.edit_max_track_per_page;
                    const start_x = track_width / 2 + edit_area[0] - editing_note_dx;
                    editing_note_lines_remove_areas.length = 0;
                    editing_note_lines_note_areas.length = 0;

                    editing_lines.push(null);

                    let currx = start_x;
                    for (const lineidx of editing_lines) {
                        epr.drawLineEx(
                            currx, 0,
                            currx, ah,
                            ah / 200,
                            "rgb(52, 52, 52)"
                        );

                        if (lineidx !== null) {
                            const line = ChartUtils.lineFromIdx(lineidx);
                            for (const note of line.notes) {
                                const startY = gety(note.time.value);
                                const endY = gety(note.endTime.value);
                                const noteIm = config.note_imgs[note.resname];
                                const noteWidth = track_width * 0.8;
                                const noteHeight = noteWidth / noteIm.width * noteIm.height;

                                if (endY - noteHeight / 2 > ah) continue;

                                epr.save();
                                if (editing_note === note.index || boxingNoteIdxs.includes(note.index)) applyCtxColorFilter(epr, 0.0, 1.0, 0.0);
                                if (!note.ishold) {
                                    epr.drawRotateImage(
                                        noteIm,
                                        currx, startY,
                                        noteWidth, noteHeight, -90
                                    );

                                    editing_note_lines_note_areas.push([note.index, [currx - noteWidth / 2, startY - noteHeight / 2, noteWidth, noteHeight]]);
                                } else {
                                    const atlas = config.res_meta[note.morebets ? "holdDoubleAtlas" : "holdAtlas"];
                                    const headLength = tailLength = noteWidth / 2;
                                    const bodyLength = Math.max(0.0, Math.abs(endY - startY));
                                    const holdTotalLength = headLength + bodyLength + tailLength;

                                    epr.drawAnchorWCenterRotateImage(
                                        ctx.createTempClip(
                                            noteIm, atlas,
                                            noteWidth, 
                                            headLength, bodyLength, tailLength
                                        ),
                                        currx, startY,
                                        holdTotalLength, noteWidth,
                                        -90, 1.0,
                                        -headLength
                                    );

                                    editing_note_lines_note_areas.push([note.index, [currx - noteWidth / 2, startY - holdTotalLength + headLength, noteWidth, holdTotalLength]]);
                                }
                                epr.restore();

                                if (startY < -ah) break;
                            }

                            const lineIdxDisplaySize = [
                                track_width * 0.8,
                                track_width * 0.8 / 16 * 9
                            ];
                            const lineIdxDisplayRect = [
                                currx, lineIdxDisplaySize[1],
                                ...lineIdxDisplaySize
                            ];
                            epr.roundRectEx(
                                lineIdxDisplayRect[0] - lineIdxDisplayRect[2] / 2,
                                lineIdxDisplayRect[1] - lineIdxDisplayRect[3] / 2,
                                lineIdxDisplayRect[2],
                                lineIdxDisplayRect[3],
                                lineIdxDisplayRect[3] / 2,
                                "rgb(120, 169, 218)"
                            );

                            epr.drawTextEx(
                                `${lineidx}`,
                                lineIdxDisplayRect[0],
                                lineIdxDisplayRect[1],
                                `${(aw + ah) / 80}px milFontBold`,
                                "rgb(52, 52, 52)", "center", "middle"
                            );

                            editing_note_lines_remove_areas.push([
                                lineIdxDisplayRect[0] - lineIdxDisplayRect[2] / 2,
                                lineIdxDisplayRect[1] - lineIdxDisplayRect[3] / 2,
                                lineIdxDisplayRect[2],
                                lineIdxDisplayRect[3]
                            ]);
                        } else {
                            editing_note_lines_area = [
                                currx - track_width / 2,
                                currx + track_width / 2,
                                start_x - track_width / 2,
                                (edit_area[0] + edit_area[1]) / 2
                            ];
                        }

                        currx += track_width;
                    }

                    editing_note_lines_get_index_from_x = x => {
                        x -= start_x;
                        x += track_width / 2;
                        return Math.floor(x / track_width);
                    };

                    editing_note_lines_get_beat_from_y = y => parseBeatStr(fmtBeatStr(getbeat(y) + 1 / config.eop.beat_spilt / 2));

                    if (boxingNote) {
                        const x1 = Math.min(boxNoteStart[0], boxNoteEnd[0]);
                        const x2 = Math.max(boxNoteStart[0], boxNoteEnd[0]);
                        const y1 = Math.min(boxNoteStart[1], boxNoteEnd[1]);
                        const y2 = Math.max(boxNoteStart[1], boxNoteEnd[1]);
                        epr.fillRectEx(x1, y1, x2 - x1, y2 - y1, "rgba(0, 255, 0, 0.7)");
                        const lastBoxingNoteLength = boxingNote.length;
                        boxingNoteIdxs.length = 0;

                        for (const [i, [noteidx, area]] of enumerate(editing_note_lines_note_areas)) {
                            const x3 = area[0];
                            const x4 = area[0] + area[2];
                            const y3 = area[1];
                            const y4 = area[1] + area[3];

                            if (Math.max(x1, x3) <= Math.min(x2, x4) && Math.max(y1, y3) <= Math.min(y2, y4)) {
                                boxingNoteIdxs.push(noteidx);
                            }
                        }

                        if (boxingNoteIdxs.length === 0) {
                            $("#edit-page-note-edit").back_btn?.click();
                            $("#edit-page-batch-note-edit").back_btn?.click();
                        }

                        if (boxingNoteIdxs.length === 1 && lastBoxingNoteLength !== 1) {
                            into_edit_page($("#edit-page-note-edit"), {
                                noteidx: boxingNoteIdxs[0],
                            });
                        } else if (boxingNoteIdxs.length > 1 && lastBoxingNoteLength !== boxingNoteIdxs.length) {
                            if (lastBoxingNoteLength === 1) $("#edit-page-note-edit").back_btn?.click();
                            into_edit_page($("#edit-page-batch-note-edit"), {
                                noteidxs: boxingNoteIdxs.deepcopy(),
                            });
                        }
                    }

                    epr.restore();
                }

                epr.drawLineEx(
                    (edit_area[0] + edit_area[1]) / 2, 0,
                    (edit_area[0] + edit_area[1]) / 2, ah,
                    ah / 200,
                    "white"
                );

                { // event 编辑
                    editing_events_areas.length = 0;
                    editing_event_lines_area.length = 0;
                    epr.save();
                    epr.beginPath();
                    epr.rect((edit_area[0] + edit_area[1]) / 2, 0, aw, ah);
                    epr.clip();

                    const editing_events = [];
                    const all_events = [];
                    const push_events = es => {
                        es = es.filter(x => (
                            config.chart.editor.editing.event_type.includes(x.type) &&
                            config.chart.editor.editing.event_edit_filter.bearer_type.includes(x.bearer_type) &&
                            (config.chart.editor.editing.event_edit_filter.bearer.length === 0 ||
                             config.chart.editor.editing.event_edit_filter.bearer.reduce((acc, condition) => {
                                let val;
                                condition = condition.replaceAll(" ", "");
                                if (condition === "*") val = true;
                                else if (condition.includes("..")) {
                                    let [start, end] = condition.split("..");
                                    if (!start) start = "-1";
                                    if (!end) end = "999999999";
                                    val = parseInt(start) <= x.bearer && x.bearer <= parseInt(end);
                                } else val = parseInt(condition) === x.bearer;
                                return val || acc;
                             }, false))
                        ));
                        editing_events.push(...es.filter(x => (
                            (() => {
                                const [sy, ey] = [gety(x.startTime.value), gety(x.endTime.value)].sorted();
                                return (
                                    (0 <= sy && sy <= ey && ey <= ah) || // 0 s e h
                                    (sy <= 0 && 0 <= ey && ey <= ah) || // s 0 e h
                                    (sy <= 0 && 0 <= ah && ah <= ey) || // s 0 h e
                                    (0 <= sy && sy <= ah && ah <= ey) // 0 s h e
                                );
                            })()
                        )));
                        all_events.push(...es);
                    };
                    for (const line of config.chart.lines) push_events(line.animations);
                    for (const sb of config.chart.storyboards) push_events(sb.animations);
                    
                    // 几天后只有上帝看得懂了
                    const has_track_events = editing_events.filter(x => editing_events_track_map.has(x.index));
                    let max_track = -1;
                    has_track_events.forEach(x => max_track = Math.max(max_track, editing_events_track_map.get(x.index)));
                    edtracks.length = 0;
                    for (let i = 0; i <= max_track + 1; i++) edtracks.push([]);
                    has_track_events.forEach(x => edtracks[editing_events_track_map.get(x.index)].push(x));
                    edtracks.forEach(ns => ns.sortbykey(e => e.startTime.value));

                    all_events.filter(x => !editing_events_track_map.has(x.index)).forEach(x => {
                        let topflag = false;
                        const sorter = (x, y) => {
                            [x, y] = [x, y].sorted();
                            return [x, Math.max(x + 5 / ah * config.eop.beat_per_page, y)];
                        }
                        for (const [i, track] of enumerate(edtracks)) {
                            let flag = true;
                            for (const oe of track) {
                                const ot = sorter(oe.startTime.value, oe.endTime.value);
                                const t = sorter(x.startTime.value, x.endTime.value);
                                if (ot[0] + FUCK < t[1] - FUCK && t[0] + FUCK < ot[1] - FUCK) flag = false;
                            }
                            if (flag) {
                                track.push(x);
                                editing_events_track_map.set(x.index, i);
                                topflag = true
                                break;
                            }
                        }
                        if (!topflag) {
                            edtracks.push([x]);
                            editing_events_track_map.set(x.index, edtracks.length - 1);
                        }
                    });

                    const track_width = (edit_area[1] - edit_area[0]) / 2 / config.edit_max_track_per_page;
                    const start_x = track_width / 2 + edit_area[0] + (edit_area[1] - edit_area[0]) / 2 - editing_event_dx;

                    let currx = start_x;
                    for (const track of edtracks) {
                        epr.drawLineEx(
                            currx, 0,
                            currx, ah,
                            ah / 200,
                            "rgb(52, 52, 52)"
                        );

                        if (currx > edit_area[1] + track_width / 2) break;

                        for (const e of track) {
                            let [sy, ey] = [gety(e.startTime.value), gety(e.endTime.value)].sorted();
                            if (ey - sy < 5) sy = ey - 5;

                            if (ey < 0) continue;
                            if (sy > ah) break;

                            const rect = [
                                currx - track_width / 2, sy,
                                currx + track_width / 2, ey
                            ];

                            const textpady = ah / 15;
                            const texty = Math.max(Math.min((sy + ey) / 2, ah - textpady), textpady);

                            epr.save();
                            if (e.index === editing_event || boxingEventIdxs.includes(e.index)) applyCtxColorFilter(epr, 0.0, 1.0, 0.0);
                            try {
                                epr.drawGrd(
                                    [0.0, sy, 0.0, ey],
                                    [
                                        [0.0, "rgb(142, 197, 252)"],
                                        [1.0, "rgb(162, 66, 255)"]
                                    ],
                                    ...rect
                                );
                            } catch (e) {}
                            epr.restore();

                            epr.save();
                            epr.beginPath();
                            epr.rect(rect[0], rect[1], rect[2] - rect[0], rect[3] - rect[1]);
                            epr.clip();
                            const icon = config.event_icons[e.type];
                            const icon_center = [currx - track_width / 2 * 0.6, texty];
                            const icon_width = track_width / 2 * 1.37;
                            const icon_height = icon_width / icon.width * icon.height;
                            epr.drawImage(
                                icon,
                                icon_center[0] - icon_width / 2, icon_center[1] - icon_height / 2,
                                icon_width, icon_height
                            );
                            const text = `${MIL_CES.EnumAnimationBearerTypeText[e.bearer_type]}${e.bearer}`;
                            const fs = (aw + ah) / 120 * (0.84 ** Math.max(0, text.length - 3));
                            epr.drawTextEx(
                                text,
                                icon_center[0] + icon_width / 2 * 0.7, texty,
                                `${fs}px milFont`,
                                "white", "left", "middle"
                            );
                            epr.restore();

                            editing_events_areas.push([e.index, rect]);
                        }

                        currx += track_width;
                    }

                    if (boxingEvent) {
                        const x1 = Math.min(boxEventStart[0], boxEventEnd[0]);
                        const x2 = Math.max(boxEventStart[0], boxEventEnd[0]);
                        const y1 = Math.min(boxEventStart[1], boxEventEnd[1]);
                        const y2 = Math.max(boxEventStart[1], boxEventEnd[1]);
                        epr.fillRectEx(x1, y1, x2 - x1, y2 - y1, "rgba(0, 255, 0, 0.7)");
                        const lastBoxingEventLength = boxingEvent.length;
                        boxingEventIdxs.length = 0;

                        for (const [i, [noteidx, area]] of enumerate(editing_events_areas)) {
                            const [x3, y3, x4, y4] = area;

                            if (Math.max(x1, x3) <= Math.min(x2, x4) && Math.max(y1, y3) <= Math.min(y2, y4)) {
                                boxingEventIdxs.push(noteidx);
                            }
                        }

                        if (boxingEventIdxs.length === 0) {
                            $("#edit-page-event-edit").back_btn?.click();
                            $("#edit-page-batch-event-edit").back_btn?.click();
                        }

                        if (boxingEventIdxs.length === 1 && lastBoxingEventLength !== 1) {
                            into_edit_page($("#edit-page-event-edit"), {
                                eidx: boxingEventIdxs[0],
                            });
                        } else if (boxingEventIdxs.length > 1 && lastBoxingEventLength !== boxingEventIdxs.length) {
                            if (lastBoxingEventLength === 1) $("#edit-page-event-edit").back_btn?.click();
                            into_edit_page($("#edit-page-batch-event-edit"), {
                                eidxs: boxingEventIdxs.deepcopy(),
                            });
                        }
                    }

                    editing_event_lines_area = [(edit_area[1] + edit_area[0]) / 2, aw];
                    editing_event_lines_get_index_from_x = x => Math.floor((x - editing_event_lines_area[0] + editing_event_dx + track_width / 2) / track_width);
                    epr.restore();
                }
            }
        }

        (display_eop ? epr : ctx).drawTextEx(
            `${parseInt(fps)}`,
            0, display_eop ? 0 : h * (1 - chart_render_area),
            `${(w + h) / 95}px milFont`,
            "red", "left", "top"
        );

        // mctx.clear();
        // mctx.font = `${(w + h) / 105}px milFont`;
        const msg_dur = 1.5;
        msgs = msgs.filter(x => performance.now() - x.time <= msg_dur * 1000);
        // const msg_padding = h / 300;
        // for (const msg of msgs) {
        //     const textSize = mctx.getTextSize(msg.msg, mctx.font);
        //     const p = (performance.now() - msg.time) / 1000 / msg_dur;
        //     const rect = [
        //         w - (msg_padding * 3 + textSize[0]) * (1.0 - (1.0 - Utils.fixorp(p * 1.5)) ** 5),
        //         msg.y, textSize[0] + msg_padding * 2,
        //         h / 20
        //     ];

        //     mctx.globalAlpha = (p < 0.8 ? 1.0 : (1.0 - (p - 0.8) / 0.2)) * 0.6;
        //     mctx.roundRectEx(...rect, rect[3] / 4, "rgba(255, 255, 255, 0.9)");
        //     mctx.drawTextEx(
        //         msg.msg,
        //         rect[0] + msg_padding,
        //         msg.y + h / 20 / 2,
        //         mctx.font,
        //         "rgba(32, 32, 32, 0.9)", "left", "middle"
        //     );
        // }

        requestAnimationFrame(render);
    };
    render.lastCall = performance.now();

    const into_edit_page_event_handler = e => {
        const page = $(`#edit-page-${e.target.id}`);
        into_edit_page(page);
    };

    const parseBeatStr = s => {
        if (/^\d*:\d*\/\d*$/.test(s)) {
            let [block, c] = s.split("/");
            let [a, b] = block.split(":");
            a = parseInt(a);
            b = parseInt(b);
            c = parseInt(c);

            while (b >= c && c !== 0) {
                b -= c;
                a += 1;
            }

            if (a >= 0 && b >= 0 && c !== 0) {
                return [a, b, c];
            }
        } else {
            const beat = parseInt(s);
            if (!isNaN(beat) && beat >= 0) {
                return [beat, 0, 1];
            }
        }
        return null;
    };

    var editing_note = -1;
    var editing_event = -1;
    const opening_edit_page = new Set();
    const into_edit_page = (page, datas) => {
        opening_edit_page.forEach(p => p.style.display = "none");
        opening_edit_page.clear();
        opening_edit_page.add(page);
        const name_match = name => page.id === `edit-page-${name}`;

        page.style.display = "block";
        $("#rb-buttons").style.display = "none";
        doPasteEditing = () => {};
        copyEditingData = null;

        page.back_btn.addEventListener("click", () => {
            page.style.display = "none";
            $("#rb-buttons").style.display = "block";
            editing_note = -1;
            opening_edit_page.delete(page);
            onDelete = () => {};
            doCopyEditing = () => {};
        }, { once: true });

        if (name_match("bpm-edit")) {
            const onupdate = () => {
                config.chart.bpms.sort((a, b) => a.time.value - b.time.value);
                page.querySelector("#edit-page-bpm-edit-main").innerHTML = config.chart.bpms.map((e, i) => `
                    <div id="edit-page-bpm-edit-item">
                        <label id="edit-page-bpm-edit-item-index-label">${i + 1}.</label>
                        <span id="edit-page-bpm-edit-item-itlabel">开始时间:</span> <input id="edit-page-bpm-edit-item-time" value="${e.time.beatstr}" class="input-style1">
                        <span id="edit-page-bpm-edit-item-itlabel">BPM值:</span> <input id="edit-page-bpm-edit-item-bpm" value="${escapeHtml(e.bpm)}" class="input-style1">
                        <span id="edit-page-bpm-edit-item-delete-this" onclick="deleteBPM(${i})" style="height: 90%">×</span>
                    </div>
                `).join("");

                page.querySelectorAll("#edit-page-bpm-edit-item-time").forEach(e => e.addEventListener("change", onchange));
                page.querySelectorAll("#edit-page-bpm-edit-item-bpm").forEach(e => e.addEventListener("change", onchange));
            };

            const onchange = () => {
                const bpm_edit_items = page.querySelectorAll("#edit-page-bpm-edit-item");
                const now_beat = ChartUtils.sec2beat(config.audio.currentTime);

                Array.from(bpm_edit_items).map((e, i) => {
                    const raw = config.chart.bpms[i];
                    const beatstr = e.querySelector("#edit-page-bpm-edit-item-time").value;
                    const log_change = () => logger.info(`更新第${i + 1}个BPM为 ${JSON.stringify(config.chart.bpms[i])}`);
                    const try_change_time = (a, b, c) => {
                        if (a !== raw.time[0] || b !== raw.time[1] || c !== raw.time[2]) {
                            const old_time = raw.time;
                            raw.time = [a, b, c];
                            onchartchanged(`修改第${i + 1}个BPM的时间, 从${old_time.fmtbeat}到${raw.time.fmtbeat}`);
                            log_change();
                        }
                    };

                    const parsedBeat = parseBeatStr(beatstr);
                    if (parsedBeat !== null && i !== 0) try_change_time(...parsedBeat);

                    const bpm = parseFloat(e.querySelector("#edit-page-bpm-edit-item-bpm").value);
                    if (!isNaN(bpm) && bpm > 0.0) {
                        const old_bpm = raw.bpm;
                        raw.bpm = Math.min(bpm, config.max_bpm);
                        if (old_bpm !== raw.bpm) {
                            onchartchanged(`修改BPM值, 从${old_bpm}到${raw.bpm}`);
                        }
                        log_change();
                    }
                });

                config.audio.currentTime = ChartUtils.beat2sec(now_beat);
                onupdate();
            };

            window.deleteBPM = i => {
                if (config.chart.bpms.length === 1) {
                    alert("至少需要存在一个BPM");
                    return;
                }

                if (disableDeleteWarn || confirm(`确定要删除第${i + 1}个BPM吗?${spwan_delete_warn("BPM")}`)) {
                    config.chart.bpms.splice(i, 1);
                    logger.info(`删除第${i + 1}个BPM`);
                    onchartchanged(`删除第${i + 1}个BPM`);
                    onupdate();
                }
            };

            window.addNewBPM = () => {
                const now_beat = ChartUtils.sec2beat(config.audio.currentTime);
                config.chart.bpms.push({
                    time: fmtBeatStr(now_beat).replaceAll(":", "/").split("/").map(e => parseInt(e)),
                    bpm: config.chart.bpms[config.chart.bpms.length - 1].bpm,
                });
                logger.info(`添加了一个BPM${JSON.stringify(config.chart.bpms[config.chart.bpms.length - 1])}`);
                onchartchanged(`添加了一个BPM`);

                onupdate();
            };

            onupdate();
        } else if (name_match("note-edit")) {
            const note = ChartUtils.noteFromIdx(datas.noteidx);
            editing_note = datas.noteidx;

            const onupdate = () => {
                page.querySelector("#edit-page-note-edit-main").innerHTML = `
                    <span>序号: </span> <input id="edit-page-note-edit-item-idx" value="${escapeHtml(note.index)}" class="input-style1" disabled> <br>
                    <span>打击时间: </span> <input id="edit-page-bpm-note-item-time" value="${note.time.beatstr}" class="input-style1"> <br>
                    <span>结束时间: </span> <input id="edit-page-bpm-note-item-endtime" value="${note.endTime.beatstr}" class="input-style1"> <br>
                    <span>类型: </span> <select id="edit-page-note-edit-item-type" class="input-style1">
                        <option value="0"${note.type === 0 ? " selected" : ""}>Tap/Hold</option>
                        <option value="1"${note.type === 1 ? " selected" : ""}>Drag</option>
                    </select> <br>
                    <span>是否为假: </span> <input id="edit-page-note-edit-item-fake" type="checkbox"${note.isFake ? " checked" : ""} class="milckbox" onfocus="this.blur()"> <br>
                    <span>是否总是为Perfect: </span> <input id="edit-page-note-edit-item-awsperfect" type="checkbox"${note.isAlwaysPerfect ? " checked" : ""} class="milckbox" onfocus="this.blur()"> <br>
                    <span>是否为多押: ${note.morebets}</span> <br>
                    <span>是否为hold: ${note.ishold}</span> <br>
                    <br> <button id="edit-page-note-edit-item-delete" class="input-style1">删除该 note</button>
                `;

                for (const id of [
                    "edit-page-note-edit-item-idx",
                    "edit-page-bpm-note-item-time",
                    "edit-page-bpm-note-item-endtime",
                    "edit-page-note-edit-item-type",
                    "edit-page-note-edit-item-fake",
                    "edit-page-note-edit-item-awsperfect",
                ]) {
                    page.querySelector(`#${id}`).addEventListener("change", onchange);
                }

                onDelete = () => {
                    if (disableDeleteWarn || confirm(`确定要删除序号为${note.index}的note吗?${spwan_delete_warn("Note")}`)) {
                        top: for (const line of config.chart.lines) {
                            for (const [i, note] of enumerate(line.notes)) {
                                if (note.index === datas.noteidx) {
                                    line.notes.splice(i, 1);
                                    break top;
                                }
                            }
                        }
                        logger.info(`删除了序号为 ${note.index} 的note`);
                        onchartchanged(`删除了序号为 ${note.index} 的note`);
                        page.back_btn.click();
                    }
                };

                doCopyEditing = () => {
                    copyEditingData = note.index;
                };

                doPasteEditing = () => {
                    if (copyEditingData === null) return;
                    const copyNote = ChartUtils.noteFromIdx(copyEditingData);
                    const newNote = copyNote.deepcopy();
                    newNote.index = ChartUtils.nextNoteIdx();
                    const newLineIdx = editing_note_lines_get_index_from_x(offsetX);
                    const newLine = ChartUtils.lineFromIdx(config.chart.editor.editing.note[newLineIdx]);
                    if (newLine === null) return;
                    const newTime = editing_note_lines_get_beat_from_y(offsetY);
                    const dt = copyNote.endTime.value - copyNote.time.value;
                    newNote.time = newTime;
                    newNote.endTime = (newTime.value + dt).tobeat;
                    if (newNote.endTime.value < newNote.time.value) newNote.endTime = newNote.time;
                    newLine.notes.push(newNote);
                    newLine.notes.sortbykey(x => x.time.value);
                    logger.info(`复制了序号为${copyNote.index}的note到序号为${newNote.index}的note`);
                    onchartchanged(`复制了序号为${copyNote.index}的note到序号为${newNote.index}的note`);
                };

                page.querySelector("#edit-page-note-edit-item-delete").addEventListener("click", onDelete);
            };

            const onchange = () => {
                const new_data = {
                    time: parseBeatStr(page.querySelector("#edit-page-bpm-note-item-time").value),
                    endTime: parseBeatStr(page.querySelector("#edit-page-bpm-note-item-endtime").value),
                    type: parseInt(page.querySelector("#edit-page-note-edit-item-type").value),
                    isFake: page.querySelector("#edit-page-note-edit-item-fake").checked,
                    isAlwaysPerfect: page.querySelector("#edit-page-note-edit-item-awsperfect").checked,
                };

                if (new_data.time !== null) note.time = new_data.time;
                if (new_data.endTime !== null) note.endTime = new_data.endTime;
                if (note.endTime.value < note.time.value) note.endTime = note.time;
                note.type = new_data.type;
                note.isFake = new_data.isFake;
                note.isAlwaysPerfect = new_data.isAlwaysPerfect;

                logger.info(`修改了序号为${note.index}的note${JSON.stringify(note)}`);
                onchartchanged(`修改了序号为${note.index}的note`);
            };

            onupdate();
        } else if (name_match("meta-edit")) {
            const onupdate = () => {
                page.querySelector("#edit-page-meta-edit-main").innerHTML = `
                    <span>背景暗度: </span> <input id="edit-page-meta-edit-item-bg-dim" value="${escapeHtml(config.chart.meta.background_dim)}" class="input-style1"> <br>
                    <span>名称: </span> <input id="edit-page-meta-edit-item-name" value=${escapeHtml(config.chart.meta.name)} class="input-style1"> <br>
                    <span>曲绘作者: </span> <input id="edit-page-meta-edit-item-bg-artist" value=${escapeHtml(config.chart.meta.background_artist)} class="input-style1"> <br>
                    <span>音乐作者: </span> <input id="edit-page-meta-edit-item-music-artist" value=${escapeHtml(config.chart.meta.music_artist)} class="input-style1"> <br>
                    <span>谱师: </span> <input id="edit-page-meta-edit-item-charter" value=${escapeHtml(config.chart.meta.charter)} class="input-style1"> <br>
                    <span>难度名称: </span> <input id="edit-page-meta-edit-item-difficulty-name" value=${escapeHtml(config.chart.meta.difficulty_name)} class="input-style1"> <br>
                    <span>难度: </span> <input id="edit-page-meta-edit-item-difficulty" value="${escapeHtml(config.chart.meta.difficulty)}"" class="input-style1"> <br>
                    <span>谱面偏移(s): </span> <input id="edit-page-meta-edit-item-offset" value="${escapeHtml(config.chart.meta.offset)}" class="input-style1"> <br>
                `;

                for (const id of [
                    "edit-page-meta-edit-item-bg-dim",
                    "edit-page-meta-edit-item-name",
                    "edit-page-meta-edit-item-bg-artist",
                    "edit-page-meta-edit-item-music-artist",
                    "edit-page-meta-edit-item-charter",
                    "edit-page-meta-edit-item-difficulty-name",
                    "edit-page-meta-edit-item-difficulty",
                    "edit-page-meta-edit-item-offset",
                ]) {
                    page.querySelector(`#${id}`).addEventListener("change", onchange);
                }
            };

            const onchange = () => {
                const newmeta = {
                    background_dim: parseFloat(page.querySelector("#edit-page-meta-edit-item-bg-dim").value),
                    name: page.querySelector("#edit-page-meta-edit-item-name").value,
                    background_artist: page.querySelector("#edit-page-meta-edit-item-bg-artist").value,
                    music_artist: page.querySelector("#edit-page-meta-edit-item-music-artist").value,
                    charter: page.querySelector("#edit-page-meta-edit-item-charter").value,
                    difficulty_name: page.querySelector("#edit-page-meta-edit-item-difficulty-name").value,
                    difficulty: parseFloat(page.querySelector("#edit-page-meta-edit-item-difficulty").value),
                    offset: parseFloat(page.querySelector("#edit-page-meta-edit-item-offset").value),
                };

                if (!isNaN(newmeta.background_dim)) config.chart.meta.background_dim = Utils.fixorp(newmeta.background_dim);
                config.chart.meta.name = newmeta.name;
                config.chart.meta.background_artist = newmeta.background_artist;
                config.chart.meta.music_artist = newmeta.music_artist;
                config.chart.meta.charter = newmeta.charter;
                config.chart.meta.difficulty_name = newmeta.difficulty_name;
                if (!isNaN(newmeta.difficulty)) config.chart.meta.difficulty = newmeta.difficulty;
                if (!isNaN(newmeta.offset)) config.chart.meta.offset = newmeta.offset;

                logger.info(`修改了meta ${JSON.stringify(config.chart.meta)}`);
                onchartchanged("修改了meta");
                onupdate();
            };

            onupdate();
        } else if (name_match("event-edit")) {
            const onupdate = () => {
                const e = ChartUtils.eventFromIdx(datas.eidx);
                page.querySelector("#edit-page-event-edit-main").innerHTML = `
                    <span>序号: </span> <input id="edit-page-event-edit-item-index" value="${escapeHtml(e.index)}" class="input-style1" disabled> <br>
                    <span>开始时间: </span> <input id="edit-page-event-edit-item-startTime" value="${e.startTime.beatstr}" class="input-style1"> <br>
                    <span>结束时间: </span> <input id="edit-page-event-edit-item-endTime" value="${e.endTime.beatstr}" class="input-style1"> <br>
                    <span>开始值: </span> <input id="edit-page-event-edit-item-start" value="${escapeHtml(e.type === MIL_CES.EnumAnimationType.Color ? Utils.ff_int2rgba(e.start).join(",") : e.start)}" class="input-style1"> <br>
                    <span>结束值: </span> <input id="edit-page-event-edit-item-end" value="${escapeHtml(e.type === MIL_CES.EnumAnimationType.Color ? Utils.ff_int2rgba(e.end).join(",") : e.end)}" class="input-style1"> <br>
                    <span>归属对象类型: </span> <select id="edit-page-event-edit-item-bearer-type" class="input-style1">
                        <option value="0"${e.bearer_type === 0 ? " selected" : ""}>${MIL_CES.EnumAnimationBearerTypeTextLong[0]}</option>
                        <option value="1"${e.bearer_type === 1 ? " selected" : ""}>${MIL_CES.EnumAnimationBearerTypeTextLong[1]}</option>
                        <option value="2"${e.bearer_type === 2 ? " selected" : ""}>${MIL_CES.EnumAnimationBearerTypeTextLong[2]}</option>
                    </select> <br>
                    <span>归属对象序号: </span> <input id="edit-page-event-edit-item-bearer" value="${escapeHtml(e.bearer)}" class="input-style1"> <br>
                    <span>事件类型: </span> <select id="edit-page-event-edit-item-type" class="input-style1">
                        <option value="0"${e.type === 0 ? " selected" : ""}>${MIL_CES.EnumAnimationTypeName[0]}</option>
                        <option value="1"${e.type === 1 ? " selected" : ""}>${MIL_CES.EnumAnimationTypeName[1]}</option>
                        <option value="2"${e.type === 2 ? " selected" : ""}>${MIL_CES.EnumAnimationTypeName[2]}</option>
                        <option value="3"${e.type === 3 ? " selected" : ""}>${MIL_CES.EnumAnimationTypeName[3]}</option>
                        <option value="4"${e.type === 4 ? " selected" : ""}>${MIL_CES.EnumAnimationTypeName[4]}</option>
                        <option value="5"${e.type === 5 ? " selected" : ""}>${MIL_CES.EnumAnimationTypeName[5]}</option>
                        <option value="6"${e.type === 6 ? " selected" : ""}>${MIL_CES.EnumAnimationTypeName[6]}</option>
                        <option value="7"${e.type === 7 ? " selected" : ""}>${MIL_CES.EnumAnimationTypeName[7]}</option>
                        <option value="8"${e.type === 8 ? " selected" : ""}>${MIL_CES.EnumAnimationTypeName[8]}</option>
                        <option value="9"${e.type === 9 ? " selected" : ""}>${MIL_CES.EnumAnimationTypeName[9]}</option>
                        <option value="10"${e.type === 10 ? " selected" : ""}>${MIL_CES.EnumAnimationTypeName[10]}</option>
                        <option value="11"${e.type === 11 ? " selected" : ""}>${MIL_CES.EnumAnimationTypeName[11]}</option>
                        <option value="12"${e.type === 12 ? " selected" : ""}>${MIL_CES.EnumAnimationTypeName[12]}</option>
                        <option value="13"${e.type === 13 ? " selected" : ""}>${MIL_CES.EnumAnimationTypeName[13]}</option>
                        <!-- <option value="14"${e.type === 14 ? " selected" : ""}>${MIL_CES.EnumAnimationTypeName[14]}</option> --!>
                        <!-- <option value="15"${e.type === 15 ? " selected" : ""}>${MIL_CES.EnumAnimationTypeName[15]}</option> --!>
                        <!-- <option value="16"${e.type === 16 ? " selected" : ""}>${MIL_CES.EnumAnimationTypeName[16]}</option> --!>
                        <!-- <option value="17"${e.type === 17 ? " selected" : ""}>${MIL_CES.EnumAnimationTypeName[17]}</option> --!>
                        <!-- <option value="18"${e.type === 18 ? " selected" : ""}>${MIL_CES.EnumAnimationTypeName[18]}</option> --!>
                        <!-- <option value="19"${e.type === 19 ? " selected" : ""}>${MIL_CES.EnumAnimationTypeName[19]}</option> --!>
                        <!-- <option value="20"${e.type === 20 ? " selected" : ""}>${MIL_CES.EnumAnimationTypeName[20]}</option> --!>
                        <!-- <option value="21"${e.type === 21 ? " selected" : ""}>${MIL_CES.EnumAnimationTypeName[21]}</option> --!>
                        <option value="22"${e.type === 22 ? " selected" : ""}>${MIL_CES.EnumAnimationTypeName[22]}</option>
                        <option value="23"${e.type === 23 ? " selected" : ""}>${MIL_CES.EnumAnimationTypeName[23]}</option>
                    </select> <br>
                    <br> <span style="font-family: milFontBold">缓动</span> <br>
                    <span>缓动类型: </span> <select id="edit-page-event-edit-item-ease-type" class="input-style1">
                        <option value="0"${e.ease.type === 0 ? " selected" : ""}>缓入</option>
                        <option value="1"${e.ease.type === 1 ? " selected" : ""}>缓出</option>
                        <option value="2"${e.ease.type === 2 ? " selected" : ""}>缓入缓出</option>
                    </select> <br>
                    <span>缓动函数: </span> <select id="edit-page-event-edit-item-ease-function" class="input-style1">
                        <option value="0"${e.ease.press === 0 ? " selected" : ""}>${MIL_CES.EnumEasePressText[0]}</option>
                        <option value="1"${e.ease.press === 1 ? " selected" : ""}>${MIL_CES.EnumEasePressText[1]}</option>
                        <option value="2"${e.ease.press === 2 ? " selected" : ""}>${MIL_CES.EnumEasePressText[2]}</option>
                        <option value="3"${e.ease.press === 3 ? " selected" : ""}>${MIL_CES.EnumEasePressText[3]}</option>
                        <option value="4"${e.ease.press === 4 ? " selected" : ""}>${MIL_CES.EnumEasePressText[4]}</option>
                        <option value="5"${e.ease.press === 5 ? " selected" : ""}>${MIL_CES.EnumEasePressText[5]}</option>
                        <option value="6"${e.ease.press === 6 ? " selected" : ""}>${MIL_CES.EnumEasePressText[6]}</option>
                        <option value="7"${e.ease.press === 7 ? " selected" : ""}>${MIL_CES.EnumEasePressText[7]}</option>
                        <option value="8"${e.ease.press === 8 ? " selected" : ""}>${MIL_CES.EnumEasePressText[8]}</option>
                        <option value="9"${e.ease.press === 9 ? " selected" : ""}>${MIL_CES.EnumEasePressText[9]}</option>
                        <option value="10"${e.ease.press === 10 ? " selected" : ""}>${MIL_CES.EnumEasePressText[10]}</option>
                        <!-- <option value="11"${e.ease.press === 11 ? " selected" : ""}>Bezier</option> --!>
                        <!-- <option value="12"${e.ease.press === 12 ? " selected" : ""}>Custom</option> --!>
                    </select> <br>
                    <span>自定义缓动: </span> <input id="edit-page-event-edit-item-ease-custom"${e.ease.isValueExp ? " checked" : ""} type="checkbox" class="input-style1" onfocus="this.blur()"> <br>
                    <span>自定义缓动表达式: </span> <input id="edit-page-event-edit-item-ease-custom-value" value="${e.ease.cusValueExp}" class="input-style1"> <br>
                    <span>左切割: </span> <input id="edit-page-event-edit-item-ease-clip-left" value="${escapeHtml(e.ease.clipLeft)}" class="input-style1"> <br>
                    <span>右切割: </span> <input id="edit-page-event-edit-item-ease-clip-right" value="${escapeHtml(e.ease.clipRight)}" class="input-style1"> <br>
                    <canvas id="edit-page-event-edit-item-ease-canvas" width="200" height="200" style="width: 200px; height: 200px; background-color: #111;"></canvas> <br>
                    <br> <button id="edit-page-event-edit-item-delete" class="milbtn" style="display: inline-flex;">删除该 event</button> <br>
                    <br> <button id="edit-page-event-edit-item-copy-to" class="milbtn" style="display: inline-flex;">复制到...</button> <br>
                `;

                for (const id of [
                    "edit-page-event-edit-item-startTime",
                    "edit-page-event-edit-item-endTime",
                    "edit-page-event-edit-item-start",
                    "edit-page-event-edit-item-end",
                    "edit-page-event-edit-item-bearer-type",
                    "edit-page-event-edit-item-bearer",
                    "edit-page-event-edit-item-type",
                    "edit-page-event-edit-item-ease-type",
                    "edit-page-event-edit-item-ease-function",
                    "edit-page-event-edit-item-ease-custom",
                    "edit-page-event-edit-item-ease-custom-value",
                    "edit-page-event-edit-item-ease-clip-left",
                    "edit-page-event-edit-item-ease-clip-right",
                ]) {
                    page.querySelector(`#${id}`).addEventListener("change", onchange);
                }

                page.querySelector("#edit-page-event-edit-item-copy-to").addEventListener("click", () => {
                    const copy_to = prompt("请输入要复制到的对象序号, 逗号分割").replaceAll("，", ",").replaceAll(" ", "");
                    if (!copy_to) return;
                    const copy_to_list = copy_to.split(",").map(Number).filter(x => !isNaN(x));
                    const e = ChartUtils.eventFromIdx(datas.eidx);
                    for (const i of copy_to_list) {
                        if (i === e.bearer) continue;
                        const bearer_data = {
                            bearer_type: e.bearer_type,
                            bearer: i
                        };
                        const bearer = ChartUtils.objFromBearerData(bearer_data);
                        if (bearer === null) continue;
                        const new_e = e.deepcopy();
                        new_e.bearer = i;
                        new_e.index = ChartUtils.nextEventIdx();
                        bearer.animations.push(new_e);
                        bearer.animations.sortbykey(x => x.startTime.value);
                    }
                    logger.info(`复制了序号为 ${datas.eidx} 的event到 ${copy_to_list.join(",")}`);
                    onchartchanged(`复制了序号为 ${datas.eidx} 的event到 ${copy_to_list.join(",")}`);
                });

                onDelete = () => {
                    if (disableDeleteWarn || confirm(`确定要删除序号为${datas.eidx}的event吗?${spwan_delete_warn("event")}`)) {
                        const try_delete = es => {
                            for (const [i, e] of enumerate(es)) {
                                if (e.index === datas.eidx) {
                                    es.splice(i, 1);
                                    return;
                                }
                            }
                        };

                        for (const line of config.chart.lines) try_delete(line.animations);
                        for (const sb of config.chart.storyboards) try_delete(sb.animations);

                        logger.info(`删除了序号为 ${datas.eidx} 的event`);
                        onchartchanged(`删除了序号为 ${datas.eidx} 的event`);
                        page.back_btn.click();
                    }
                };

                doCopyEditing = () => {
                    copyEditingData = datas.eidx;
                };

                doPasteEditing = () => {
                    if (copyEditingData === null) return;
                    const copyE = ChartUtils.eventFromIdx(copyEditingData);
                    const newE = copyE.deepcopy();
                    newE.index = ChartUtils.nextEventIdx();
                    const newTime = editing_note_lines_get_beat_from_y(offsetY);
                    const dt = newE.endTime.value - newE.startTime.value;
                    newE.startTime = newTime;
                    newE.endTime = (newTime.value + dt).tobeat;
                    if (newE.endTime.value < newE.startTime.value) newE.endTime = newE.startTime;
                    const trackidx = editing_event_lines_get_index_from_x(offsetX);
                    const track = edtracks[trackidx];
                    if (!track) return;
                    const bearer = ChartUtils.objFromBearerData(copyE);
                    bearer.animations.push(newE);
                    bearer.animations.sortbykey(x => x.startTime.value);
                    editing_events_track_map.set(newE.index, trackidx);
                    logger.info(`粘贴了序号为 ${copyEditingData} 的event到 ${newE.index}`);
                    onchartchanged(`粘贴了序号为 ${copyEditingData} 的event到 ${newE.index}`);
                };

                page.querySelector("#edit-page-event-edit-item-delete").addEventListener("click", onDelete);

                const ecvs = page.querySelector("#edit-page-event-edit-item-ease-canvas");
                const ectx = ecvs.getContext("2d");
                ectx.clear();
                ectx.translate(0, 200);
                ectx.scale(1, -1);
                ectx.scale(0.9, 0.9);
                const lw = 3;
                ectx.lineWidth = lw;
                const startColor = [142, 197, 252];
                const endColor = [162, 66, 255];
                const getColor = p => [
                    startColor[0] + (endColor[0] - startColor[0]) * p,
                    startColor[1] + (endColor[1] - startColor[1]) * p,
                    startColor[2] + (endColor[2] - startColor[2]) * p
                ];
                const drawLine = (fx, fy) => {
                    const n = 50;
                    for (let i = 0; i < n; i++) {
                        const p = i / n;
                        const np = (i + 1) / n;
                        const x = fx(p) * 200 + lw / 2;
                        const y = fy(p) * 200 + lw / 2;
                        const nx = fx(np) * 200 + lw / 2;
                        const ny = fy(np) * 200 + lw / 2;
                        ectx.beginPath();
                        ectx.moveTo(x, y);
                        ectx.lineTo(nx, ny);
                        ectx.strokeStyle = `rgb(${getColor(p).join(",")})`;
                        ectx.stroke();
                    }
                };

                drawLine(p => p, p => 0);
                drawLine(p => 0, p => p);
                drawLine(p => p, p => (e.start !== e.end ? (e.ease.doease(p, e.start, e.end) - e.start) / (e.end - e.start) : e.ease.doease(p, 0, 1)));
            };

            const onchange = () => {
                const raw_e = ChartUtils.eventFromIdx(datas.eidx);
                const raw_bearer_data = {
                    bearer: raw_e.bearer,
                    bearer_type: raw_e.bearer_type,
                };
                let etype = parseInt($("#edit-page-event-edit-item-type").value);
                if (!isNaN(etype) && 0 <= etype && etype <= 23) raw_e.type = etype;
                etype = raw_e.type;
                const parseEventVal = v => {
                    if (etype !== MIL_CES.EnumAnimationType.Color) return parseFloat(v);
                    if (v.startsWith("#")) {
                        v = [`${v[1]}${v[2]}`, `${v[3]}${v[4]}`, `${v[5]}${v[6]}`, `${v[7]}${v[8]}`].map(x => parseInt(x, 16)).map(String).join(",");
                    }
                    return Utils.ff_rgba2int(v.replaceAll("，", ",").replaceAll("、", ",").split(",").map(x => parseInt(x)));
                };
                const new_data = {
                    startTime: parseBeatStr($("#edit-page-event-edit-item-startTime").value),
                    endTime: parseBeatStr($("#edit-page-event-edit-item-endTime").value),
                    start: parseEventVal($("#edit-page-event-edit-item-start").value),
                    end: parseEventVal($("#edit-page-event-edit-item-end").value),
                    bearer_type: parseInt($("#edit-page-event-edit-item-bearer-type").value),
                    bearer: parseInt($("#edit-page-event-edit-item-bearer").value),
                    ease: {
                        type: parseInt($("#edit-page-event-edit-item-ease-type").value),
                        press: parseInt($("#edit-page-event-edit-item-ease-function").value),
                        isValueExp: $("#edit-page-event-edit-item-ease-custom").checked,
                        cusValueExp: $("#edit-page-event-edit-item-ease-custom-value").value,
                        clipLeft: parseFloat($("#edit-page-event-edit-item-ease-clip-left").value),
                        clipRight: parseFloat($("#edit-page-event-edit-item-ease-clip-right").value),
                    },
                };

                let st = raw_e.startTime;
                let et = raw_e.endTime;

                if (new_data.startTime !== null) st = new_data.startTime;
                if (new_data.endTime !== null) et = new_data.endTime;

                let event_overlap = false;
                const allAnimations = ChartUtils.getAllAnimations();

                for (const e of allAnimations) {
                    if (e.bearer_type === raw_e.bearer_type && e.bearer === raw_e.bearer && e.type === raw_e.type && e.index !== raw_e.index) {
                        const ot = [e.startTime.value, e.endTime.value];
                        const t = [st.value, et.value];
                        if (ot[0] + FUCK < t[1] - FUCK && t[0] + FUCK < ot[1] - FUCK) {
                            event_overlap = true;
                            break;
                        }
                    }
                }

                if (st.value < et.value && !event_overlap) {
                    raw_e.startTime = st;
                    raw_e.endTime = et;
                }

                if (!isNaN(new_data.start)) raw_e.start = new_data.start;
                if (!isNaN(new_data.end)) raw_e.end = new_data.end;
                if (!isNaN(new_data.bearer_type) && 0 <= new_data.bearer_type && new_data.bearer_type <= 2) raw_e.bearer_type = new_data.bearer_type;
                if (!isNaN(new_data.bearer) && new_data.bearer >= 0) raw_e.bearer = new_data.bearer;
                if (!isNaN(new_data.ease.type) && 0 <= new_data.ease.type && new_data.ease.type <= 2) raw_e.ease.type = new_data.ease.type;
                if (!isNaN(new_data.ease.press) && 0 <= new_data.ease.press && new_data.ease.press <= 12) raw_e.ease.press = new_data.ease.press;
                raw_e.ease.isValueExp = new_data.ease.isValueExp;
                raw_e.ease.cusValueExp = new_data.ease.cusValueExp;
                if (!isNaN(new_data.ease.clipLeft)) raw_e.ease.clipLeft = Utils.fixorp(new_data.ease.clipLeft);
                if (!isNaN(new_data.ease.clipRight)) raw_e.ease.clipRight = Utils.fixorp(new_data.ease.clipRight);

                if (raw_bearer_data.bearer_type !== raw_e.bearer_type || raw_bearer_data.bearer !== raw_e.bearer) {
                    const raw_bearer = ChartUtils.objFromBearerData(raw_bearer_data);
                    const new_bearer = ChartUtils.objFromBearerData(raw_e);
                    if (new_bearer === null) {
                        raw_e.bearer_type = raw_bearer_data.bearer_type;
                        raw_e.bearer = raw_bearer_data.bearer;
                    } else {
                        raw_bearer.animations = raw_bearer.animations.filter(e => e.index !== raw_e.index);
                        new_bearer.animations.push(raw_e);
                        new_bearer.animations.sortbykey(x => x.startTime.value);
                    }
                }

                logger.info(`修改了序号为${datas.eidx}的event${JSON.stringify(raw_e)}`);
                onchartchanged(`修改了序号为${datas.eidx}的event`);

                onupdate();
            };

            onupdate();
        } else if (name_match("line-edit")) {
            const onupdate = () => {
                page.querySelector("#edit-page-line-edit-main").innerHTML = config.chart.lines.map(line => {
                    return `
                        <div id="edit-page-line-edit-item-${line.index}">
                            <span>${line.index}. </span>
                            <span>${line.notes.length} notes</span>
                            <span>${line.animations.length} animatinos</span>
                            <button id="edit-page-line-edit-item-delete-this" class="milbtn" style="display: inline-flex" onclick="removeLine(${line.index})">×</button>
                        </div>
                    `;
                }).join("");
            };

            const onchange = () => {
                // TODO
            };

            onupdate();

            window.removeLine = idx => {
                if (disableDeleteWarn || confirm(`确定删除第${idx}条轨道吗？${spwan_delete_warn("轨道")}`)) {
                    for (const [i, line] of enumerate(config.chart.lines)) {
                        if (line.index === idx) {
                            config.chart.lines.splice(i, 1);
                            break;
                        }
                    }

                    logger.info(`删除了序号为${idx}的line`);
                    onchartchanged(`删除了序号为${idx}的line`);
                    ChartUtils.optIdx();
                    onupdate();
                }
            };

            window.addNewLine = () => {
                const newLine = {
                    notes: [],
                    animations: [],
                    index: ChartUtils.nextLineIdx(),
                };

                newLine.animations.push(newDefaultSpeedEvent(ChartUtils.nextEventIdx(), newLine.index));

                config.chart.lines.push(newLine);

                logger.info(`添加了新的line`);
                onchartchanged(`添加了新的line`);
                onupdate();
            };
        } else if (name_match("sb-edit")) {
            const onupdate = () => {
                page.querySelector("#edit-page-sb-edit-main").innerHTML = config.chart.storyboards.map(sb => {
                    return `
                        <div id="edit-page-sb-edit-item-${sb.index}">
                            <span>${sb.index}. </span>
                            <span>类型: </span> <select id="edit-page-sb-edit-item-type-select" class="milbtn" style="display: inline-flex;">
                                <option value="0"${sb.type === 0 ? " selected" : ""}>${MIL_CES.EnumStoryboardTypeName[0]}</option>
                                <option value="1"${sb.type === 1 ? " selected" : ""}>${MIL_CES.EnumStoryboardTypeName[1]}</option>
                                <option value="2"${sb.type === 2 ? " selected" : ""}>${MIL_CES.EnumStoryboardTypeName[2]}</option>
                            </select>${sb.type === 0 && !(sb.data in config.storyboard_res) ? `
                                <span style="color: red; font-family: milFontBold"> !未找到资源</span>
                            ` : ""}
                            <span>层级: </span> <select id="edit-page-sb-edit-item-layer-select" class="milbtn" style="display: inline-flex;">
                                <option value="0"${sb.layer === 0 ? " selected" : ""}>${MIL_CES.EnumStoryboardLayerName[0]}</option>
                                <option value="1"${sb.layer === 1 ? " selected" : ""}>${MIL_CES.EnumStoryboardLayerName[1]}</option>
                                <option value="2"${sb.layer === 2 ? " selected" : ""}>${MIL_CES.EnumStoryboardLayerName[2]}</option>
                            </select> <br>
                            <span>数据: </span> <input id="edit-page-sb-edit-item-data-input" class="input-style1" value=${JSON.stringify(sb.data)} style="display: inline-flex;"> <br>
                            <button id="edit-page-sb-edit-item-delete-this" class="milbtn" style="display: inline-flex" onclick="removeSB(${sb.index})" style="display: inline-flex">×</button>
                        </div>
                    `;
                }).join("<br>");

                for (const sb of config.chart.storyboards) {
                    const item = page.querySelector(`#edit-page-sb-edit-item-${sb.index}`);

                    for (const id of [
                        "edit-page-sb-edit-item-type-select",
                        "edit-page-sb-edit-item-layer-select",
                        "edit-page-sb-edit-item-data-input"
                    ]) {
                        item.querySelector(`#${id}`).onchange = () => {
                            const newvals = {
                                type: parseInt(item.querySelector("#edit-page-sb-edit-item-type-select").value),
                                layer: parseInt(item.querySelector("#edit-page-sb-edit-item-layer-select").value),
                                data: item.querySelector("#edit-page-sb-edit-item-data-input").value,
                            };

                            if (!isNaN(newvals.type) && 0 <= newvals.type && newvals.type <= 2) sb.type = newvals.type;
                            if (!isNaN(newvals.layer) && 0 <= newvals.layer && newvals.layer <= 2) sb.layer = newvals.layer;
                            sb.data = newvals.data;
                            logger.info(`修改了序号为${sb.index}的storyboard数据为${sb}`);
                            onchartchanged(`修改了序号为${sb.index}的storyboard数据为${sb}`);
                            onupdate();
                        };
                    }
                }
            };

            onupdate();

            window.removeSB = idx => {
                if (disableDeleteWarn || confirm(`确定删除序号为${idx}的storyboard吗？${spwan_delete_warn("storyboard")}`)) {
                    for (const [i, sb] of enumerate(config.chart.storyboards)) {
                        if (sb.index === idx) {
                            config.chart.storyboards.splice(i, 1);
                            break;
                        }
                    }

                    logger.info(`删除了序号为${idx}的storyboard`);
                    onchartchanged(`删除了序号为${idx}的storyboard`);
                    ChartUtils.optIdx();
                    onupdate();
                }
            };

            window.addNewSb = () => {
                config.chart.storyboards.push({
                    type: 0,
                    data: "builtin.line",
                    layer: 0,
                    animations: [],
                    index: ChartUtils.nextSbIdx(),
                });

                logger.info(`添加了新的storyboard`);
                onchartchanged(`添加了新的storyboard`);
                onupdate();
            };
        } else if (name_match("script-run")) {
            const main = page.querySelector("#edit-page-script-run-main");
            main.innerHTML = "";
            // const monacoContainer = document.createElement("div");
            // monacoContainer.id = "edit-page-script-run-monaco-container";
            // const monacoEditor = monaco.editor.create(monacoContainer, {
            //     value: "// Write your script here",
            //     language: "javascript",
            //     theme: "vs-dark",
            // });
            // page.querySelector("#edit-page-script-run-main").appendChild(monacoContainer);

            const textarea = document.createElement("textarea");
            textarea.id = "edit-page-script-run-monaco-container";
            textarea.value = "// monaco editor 去报错了, 用 textarea 吧";
            main.appendChild(textarea);
            main.appendChild(document.createElement("br"));

            main.appendChild(document.createElement("br"));
            const presetLabel = document.createElement("label");
            presetLabel.innerHTML = "预设";
            presetLabel.style.fontFamily = "milFontBold";
            main.appendChild(presetLabel);
            main.appendChild(document.createElement("br"));

            for (const k in config.scripts) {
                const btn = document.createElement("button");
                btn.innerHTML = k;
                btn.classList.add("milbtn");
                btn.style.display = "inline-flex";
                btn.style.padding = "5px";
                btn.onclick = () => {
                    if (!confirm(`确定要使用预设 ${k} 吗？`)) return;
                    textarea.value = config.scripts[k];
                };
                main.appendChild(btn);
                main.appendChild(document.createElement("br"));
            }

            window.runScript = () => {
                try {
                    eval(textarea.value);
                } catch (e) {
                    alert(e);
                    console.error(e);
                }
                alert("脚本执行完毕");
            };
        } else if (name_match("batch-note-edit")) {
            page.querySelector("#edit-page-batch-note-edit-main").innerHTML = `
                <span>批量编辑note: ${datas.noteidxs.join(",")}</span> <br> <br>
                <span>修改属性: </span> <select id="edit-page-batch-note-edit-property-select" class="input-style1" style="display: inline-flex;">
                    <option value="type" selected>type</option>
                    <option value="time">time</option>
                    <option value="endTime">endTime</option>
                    <option value="isFake">isFake</option>
                    <option value="isAlwaysPerfect">isAlwaysPerfect</option>
                    <option value="wholeTime">wholeTime</option>
                    <option value="holdLength">holdLength</option>
                </select> <br>
                <span>修改方式: </span> <select id="edit-page-batch-note-edit-mode-select" class="input-style1" style="display: inline-flex;"> </select> <br>
                <span>修改值: </span> <div id="edit-page-batch-note-edit-value-container" style="display: inline-flex"></div>
                <br> <button id="edit-page-batch-note-edit-item-delete" class="milbtn" style="display: inline-flex;">删除这些 note</button>
            `;

            const updateForm = () => {
                const property = $("#edit-page-batch-note-edit-property-select").value;
                const mode_select = $("#edit-page-batch-note-edit-mode-select");

                const options = {
                    type: ["set"],
                    time: ["set", "add", "sub", "mul", "div"],
                    endTime: ["set", "add", "sub", "mul", "div"],
                    isFake: ["set", "not", "xor"],
                    isAlwaysPerfect: ["set", "not", "xor"],
                    wholeTime: ["set", "add", "sub", "mul", "div"],
                    holdLength: ["set", "add", "sub", "mul", "div"],
                }[property];

                mode_select.innerHTML = options.map(v => `<option value=${v}>${v}</option>`).join("");

                const value_container = $("#edit-page-batch-note-edit-value-container");
                const value_input_map = {
                    type: { type: "select", data: [[MIL_CES.EnumNoteType.Hit, "Hit"], [MIL_CES.EnumNoteType.Drag, "Drag"]] },
                    time: { type: "input", transformer: x => {
                        const time = parseFloat(x);
                        if (isNaN(time)) return null;
                        return time;
                    }, input_type: "number", default: 1.0 },
                    endTime: { type: "alias-copy", data: "time" },
                    isFake: { type: "select", data: [[true, "true"], [false, "false"]] },
                    isAlwaysPerfect: { type: "select", data: [[true, "true"], [false, "false"]] },
                    wholeTime: { type: "alias-copy", data: "time" },
                    holdLength: { type: "alias-copy", data: "time" },
                };

                let value_input = value_input_map[property];
                if (value_input.type === "alias-copy") value_input = value_input_map[value_input.data];

                if (value_input.type === "select") {
                    value_container.innerHTML = `
                        <select class="input-style1" style="display: inline-flex;" id="edit-page-batch-note-edit-value-input">
                            ${value_input.data.map((item, idx) => `
                                <option value="${item[0]}"${idx === 0 ? " selected" : ""}>${item[1]}</option>
                            `).join("")}
                        </select>
                    `;
                } else if (value_input.type === "input") {
                    value_container.innerHTML = `
                        <input class="input-style1" style="display: inline-flex;" type="${value_input.input_type}" value="${value_input.default}" id="edit-page-batch-note-edit-value-input">
                    `;
                } else {
                    // ??
                }

                const applyTimeProp = (note, prop, value, mode) => {
                    const raw_time = note[prop];

                    if (mode === "set") note[prop] = value.tobeat;
                    else if (mode === "add") note[prop] = (note[prop].value + value).tobeat;
                    else if (mode === "sub") note[prop] = (note[prop].value - value).tobeat;
                    else if (mode === "mul") note[prop] = (note[prop].value * value).tobeat;
                    else if (mode === "div") note[prop] = (note[prop].value / value).tobeat;

                    if (note[prop] === null) note[prop] = raw_time;
                };

                const applyBoolProp = (note, prop, value, mode) => {
                    value = value.toString();
                    value = value === "false" ? false : true;
                    if (mode === "set") note[prop] = value;
                    else if (mode === "not") note[prop] = !note[prop];
                    else if (mode === "xor") note[prop] = note[prop] ^ value;
                };

                window.applyBatchEditNote = () => {
                    let value = value_container.querySelector("#edit-page-batch-note-edit-value-input").value;
                    if (value_input.transformer) value = value_input.transformer(value);
                    if (value === null) {
                        alert("输入值无效");
                        return;
                    }
                    const notes = datas.noteidxs.map(ChartUtils.noteFromIdx);
                    const mode = mode_select.value;

                    for (const note of notes) {
                        if (property === "type") {
                            note.type = parseInt(value);
                        } else if (property === "time") {
                            applyTimeProp(note, property, value, mode);
                            if (note.time.value > note.endTime.value) note.endTime = note.time;
                        } else if (property === "endTime") {
                            applyTimeProp(note, property, value, mode);
                            if (note.time.value > note.endTime.value) note.endTime = note.time;
                        } else if (property === "isFake") {
                            applyBoolProp(note, property, value, mode);
                        } else if (property === "isAlwaysPerfect") {
                            applyBoolProp(note, property, value, mode);
                        } else if (property == "wholeTime") {
                            applyTimeProp(note, "time", value, mode);
                            applyTimeProp(note, "endTime", value, mode);
                            if (note.time.value > note.endTime.value) note.endTime = note.time;
                        } else if (property == "holdLength") {
                            note.dt = (note.endTime.value - note.time.value).tobeat;
                            applyTimeProp(note, "dt", value, mode);
                            note.endTime = (note.time.value + note.dt.value).tobeat;
                            if (note.time.value > note.endTime.value) note.endTime = note.time;
                            delete note.dt;
                        } else {
                            // ??
                        }
                    };
                    
                    logger.info(`批量编辑note: ${datas.noteidxs.join(",")}`);
                    onchartchanged("批量编辑note");
                };
            };

            doCopyEditing = () => {
                copyEditingData = datas.noteidxs.deepcopy();
            };

            doPasteEditing = () => {
                if (copyEditingData === null) return;
                const newTime = editing_note_lines_get_beat_from_y(offsetY);
                const changedLines = new Set();
                const copyNotes = [];
                for (const noteidx of copyEditingData) {
                    const copyNote = ChartUtils.noteFromIdx(noteidx);
                    copyNotes.push(copyNote);
                }
                const minTime = Math.min(...copyNotes.map(x => x.time.value));
                const dt = newTime.value - minTime;

                for (const copyNote of copyNotes) {
                    const newNote = copyNote.deepcopy();
                    newNote.index = ChartUtils.nextNoteIdx();
                    newNote.time = (newNote.time.value + dt).tobeat;
                    newNote.endTime = (newNote.endTime.value + dt).tobeat;
                    const newLine = ChartUtils.lineFromNoteIdx(copyNote.index);
                    newLine.notes.push(newNote);
                    changedLines.add(newLine);
                }
                changedLines.forEach(x => x.notes.sortbykey(x => x.time.value));
                logger.info(`批量复制了序号为${copyEditingData.join(",")}的note到${newTime.beatstr}`);
                onchartchanged(`批量复制了序号为${copyEditingData.join(",")}的note`);
            };

            onDelete = () => {
                if (disableDeleteWarn || confirm(`确定要删除序号为${datas.noteidxs.join(",")}的note吗?${spwan_delete_warn("note")}`)) {
                    const try_delete = ns => {
                        for (let i = 0; i < ns.length; i++) {
                            if (datas.noteidxs.includes(ns[i].index)) {
                                ns.splice(i, 1);
                                i--;
                            }
                        }
                    };
                    
                    for (const line of config.chart.lines) try_delete(line.notes);

                    logger.info(`删除了序号为 ${datas.noteidxs.join(",")} 的note`);
                    onchartchanged(`删除了序号为 ${datas.noteidxs.join(",")} 的note`);
                    page.back_btn.click();
                }
            };

            updateForm();
            $("#edit-page-batch-note-edit-item-delete").addEventListener("click", onDelete);
            $("#edit-page-batch-note-edit-property-select").onchange = updateForm;
        } else if (name_match("batch-event-edit")) {
            page.querySelector("#edit-page-batch-event-edit-main").innerHTML = `
                <span>批量编辑event: ${datas.eidxs.join(",")}</span> <br> <br>
                <span>修改属性: </span> <select id="edit-page-batch-event-edit-property-select" class="input-style1" style="display: inline-flex;">
                    <option value="startTime" selected>startTime</option>
                    <option value="endTime">endTime</option>
                    <option value="start">start</option>
                    <option value="end">end</option>
                    <option value="type">type</option>
                    <option value="bearer_type">bearer_type</option>
                    <option value="bearer">bearer</option>
                    <option value="ease.type">ease.type</option>
                    <option value="ease.press">ease.press</option>
                    <option value="ease.isValueExp">ease.isValueExp</option>
                    <option value="ease.cusValueExp">ease.cusValueExp</option>
                    <option value="ease.clipLeft">ease.clipLeft</option>
                    <option value="ease.clipRight">ease.clipRight</option>
                    <option value="wholeTime">wholeTime</option>
                    <option value="wholeValue">wholeValue</option>
                </select> <br>
                <span>修改方式: </span> <select id="edit-page-batch-event-edit-mode-select" class="input-style1" style="display: inline-flex;"> </select> <br>
                <span>修改值: </span> <div id="edit-page-batch-event-edit-value-container" style="display: inline-flex"></div>
                <br> <button id="edit-page-batch-event-edit-item-delete" class="milbtn" style="display: inline-flex;">删除这些 event</button>
            `;

            const updateForm = () => {
                const property = $("#edit-page-batch-event-edit-property-select").value;
                const mode_select = $("#edit-page-batch-event-edit-mode-select");

                const options = {
                    startTime: ["set", "add", "sub", "mul", "div"],
                    endTime: ["set", "add", "sub", "mul", "div"],
                    start: ["set", "add", "sub", "mul", "div"],
                    end: ["set", "add", "sub", "mul", "div"],
                    type: ["set"],
                    bearer_type: ["set"],
                    bearer: ["set"],
                    "ease.type": ["set"],
                    "ease.press": ["set"],
                    "ease.isValueExp": ["set", "not", "xor"],
                    "ease.cusValueExp": ["set"],
                    "ease.clipLeft": ["set", "add", "sub", "mul", "div"],
                    "ease.clipRight": ["set", "add", "sub", "mul", "div"],
                    wholeTime: ["set", "add", "sub", "mul", "div"],
                    wholeValue: ["set", "add", "sub", "mul", "div"],
                }[property];

                mode_select.innerHTML = options.map(v => `<option value=${v}>${v}</option>`).join("");

                const value_container = $("#edit-page-batch-event-edit-value-container");
                const value_input_map = {
                    startTime: { type: "input", transformer: x => {
                        const time = parseFloat(x);
                        if (isNaN(time)) return null;
                        return time;
                    }, input_type: "number", default: 1.0 },
                    endTime: { type: "alias-copy", data: "startTime" },
                    start: { type: "input", input_type: "number", default: 0.0 },
                    end: { type: "input", input_type: "number", default: 0.0 },
                    type: { type: "select", data: Array.from( {length: 24} ).map(i => {[i, MIL_CES.EnumAnimationTypeName[i]]}) },
                    bearer_type: { type: "input", transformer: x => {
                        x = parseInt(x);
                        if (isNaN(x) || !(0 <= x && x <= 2)) return null;
                        return x;
                    }, input_type: "number", default: 0 },
                    bearer: { type: "input", transformer: x => {
                        x = parseInt(x);
                        if (isNaN(x) || 0 < x) return null;
                        return x;
                    }, input_type: "number", default: 0 },
                    "ease.type": { type: "select", data: Array.from( {length: 3} ).map(i => [i, MIL_CES.EnumEaseTypeText[i]]) },
                    "ease.press": { type: "select", data: Array.from( { length: 11 } ).map(i => [i, MIL_CES.EnumEasePressText[i]]) },
                    "ease.isValueExp": { type: "select", data: [[true, "true"], [false, "false"]] },
                    "ease.cusValueExp": { type: "input", input_type: "text", default: "" },
                    "ease.clipLeft": { type: "input", transformer: x => {
                        x = parseFloat(x);
                        if (isNaN(x)) return null;
                        return Utils.fixorp(x);
                    }, input_type: "number", default: 0.0 },
                    "ease.clipRight": { type: "input", transformer: x => {
                        x = parseFloat(x);
                        if (isNaN(x)) return null;
                        return Utils.fixorp(x);
                    }, input_type: "number", default: 0.0 },
                    wholeTime: { type: "alias-copy", data: "startTime" },
                    wholeValue: { type: "input", input_type: "number", default: 0.0 },
                };

                let value_input = value_input_map[property];
                if (value_input.type === "alias-copy") value_input = value_input_map[value_input.data];

                if (value_input.type === "select") {
                    value_container.innerHTML = `
                        <select class="input-style1" style="display: inline-flex;" id="edit-page-batch-event-edit-value-input">
                            ${value_input.data.map((item, idx) => `
                                <option value="${item[0]}"${idx === 0 ? " selected" : ""}>${item[1]}</option>
                            `).join("")}
                        </select>
                    `;
                } else if (value_input.type === "input") {
                    value_container.innerHTML = `
                        <input class="input-style1" style="display: inline-flex;" type="${value_input.input_type}" value="${value_input.default}" id="edit-page-batch-event-edit-value-input">
                    `;
                } else {
                    // ??
                }

                const applyTimeProp = (event, prop, value, mode) => {
                    const raw_time = event[prop];

                    if (mode === "set") event[prop] = value.tobeat;
                    else if (mode === "add") event[prop] = (event[prop].value + value).tobeat;
                    else if (mode === "sub") event[prop] = (event[prop].value - value).tobeat;
                    else if (mode === "mul") event[prop] = (event[prop].value * value).tobeat;
                    else if (mode === "div") event[prop] = (event[prop].value / value).tobeat;

                    if (event[prop] === null) event[prop] = raw_time;
                };

                const applyBoolProp = (event, prop, value, mode) => {
                    value = value.toString();
                    value = value === "false" ? false : true;
                    if (mode === "set") event[prop] = value;
                    else if (mode === "not") event[prop] = !event[prop];
                    else if (mode === "xor") event[prop] = event[prop] ^ value;
                };

                const applyValueProp = (event, prop, value, mode) => {
                    value = parseFloat(value);
                    const raw_value = event[prop];

                    if (mode === "set") event[prop] = value;
                    else if (mode === "add") event[prop] = event[prop] + value;
                    else if (mode === "sub") event[prop] = event[prop] - value;
                    else if (mode === "mul") event[prop] = event[prop] * value;
                    else if (mode === "div") event[prop] = event[prop] / value;

                    const changed = parseFloat(event[prop]);
                    if (isNaN(changed) || !isFinite(changed)) event[prop] = raw_value;
                };

                window.applyBatchEditEvent = () => {
                    let value = value_container.querySelector("#edit-page-batch-event-edit-value-input").value;
                    if (value_input.transformer) value = value_input.transformer(value);
                    if (value === null) {
                        alert("输入值无效");
                        return;
                    }
                    const events = datas.eidxs.map(ChartUtils.eventFromIdx);
                    const mode = mode_select.value;

                    for (const e of events) {
                        const raw_bearer_data = {
                            bearer_type: e.bearer_type,
                            bearer: e.bearer
                        };

                        if (property === "startTime") {
                            applyTimeProp(e, property, value, mode);
                            if (e.endTime.value < e.startTime.value) e.startTime = e.endTime;
                        } else if (property === "endTime") {
                            applyTimeProp(e, property, value, mode);
                            if (e.endTime.value < e.startTime.value) e.startTime = e.endTime;
                        } else if (property === "start") {
                            applyValueProp(e, property, value, mode);
                        } else if (property === "end") {
                            applyValueProp(e, property, value, mode);
                        } else if (property === "type") {
                            e.type = parseInt(value);
                        } else if (property === "bearer_type") {
                            e.bearer_type = parseInt(value);
                        } else if (property === "bearer") {
                            e.bearer = parseInt(value);
                        } else if (property === "ease.type") {
                            e.ease.type = parseInt(value);
                        } else if (property === "ease.press") {
                            e.ease.press = parseFloat(value);
                        } else if (property === "ease.isValueExp") {
                            applyBoolProp(e.ease, "isValueExp", value, mode);
                        } else if (property === "ease.cusValueExp") {
                            e.ease.cusValueExp = value;
                        } else if (property === "ease.clipLeft") {
                            applyValueProp(e.ease, "clipLeft", value, mode);
                        } else if (property === "ease.clipRight") {
                            applyValueProp(e.ease, "clipRight", value, mode);
                        } else if (property === "wholeTime") {
                            applyTimeProp(e, "startTime", value, mode);
                            applyTimeProp(e, "endTime", value, mode);
                            if (e.endTime.value < e.startTime.value) e.startTime = e.endTime;
                        } else if (property === "wholeValue") {
                            applyValueProp(e, "start", value, mode);
                            applyValueProp(e, "end", value, mode);
                        }

                        const newObj = ChartUtils.objFromBearerData(e);
                        if (newObj === null) {
                            e.bearer_type = raw_bearer_data.bearer_type;
                            e.bearer = raw_bearer_data.bearer;
                        }
                    };
                    
                    logger.info(`批量编辑event: ${datas.eidxs.join(",")}`);
                    onchartchanged("批量编辑event");
                };
            };

            doCopyEditing = () => {
                copyEditingData = datas.eidxs.deepcopy();
            };

            doPasteEditing = () => {
                if (copyEditingData === null) return;
                const newTime = editing_note_lines_get_beat_from_y(offsetY);
                const changedObjs = new Set();
                const copyEvents = [];
                for (const eidx of copyEditingData) {
                    const copyEvent = ChartUtils.eventFromIdx(eidx);
                    copyEvents.push(copyEvent);
                }
                const minTime = Math.min(...copyEvents.map(x => x.startTime.value));
                const dt = newTime.value - minTime;

                for (const copyEvent of copyEvents) {
                    const newEvent = copyEvent.deepcopy();
                    newEvent.index = ChartUtils.nextEventIdx();
                    newEvent.startTime = (newEvent.startTime.value + dt).tobeat;
                    newEvent.endTime = (newEvent.endTime.value + dt).tobeat;
                    const newObj = ChartUtils.objFromBearerData(copyEvent);
                    newObj.animations.push(newEvent);
                    changedObjs.add(newObj);
                }

                changedObjs.forEach(x => x.animations.sortbykey(x => x.startTime.value));
                logger.info(`批量复制了序号为${copyEditingData.join(",")}的event到${newTime.beatstr}`);
                onchartchanged(`批量复制了序号为${copyEditingData.join(",")}的event`);
            };

            onDelete = () => {
                if (disableDeleteWarn || confirm(`确定要删除序号为${datas.eidxs.join(",")}的event吗?${spwan_delete_warn("event")}`)) {
                    const try_delete = es => {
                        for (let i = 0; i < es.length; i++) {
                            if (datas.eidxs.includes(es[i].index)) {
                                es.splice(i, 1);
                                i--;
                            }
                        }
                    };
                    
                    for (const line of config.chart.lines) try_delete(line.animations);
                    for (const sb of config.chart.storyboards) try_delete(sb.animations);

                    logger.info(`删除了序号为 ${datas.eidxs.join(",")} 的event`);
                    onchartchanged(`删除了序号为 ${datas.eidxs.join(",")} 的event`);
                    page.back_btn.click();
                }
            };

            updateForm();
            $("#edit-page-batch-event-edit-item-delete").addEventListener("click", onDelete);
            $("#edit-page-batch-event-edit-property-select").onchange = updateForm;
        } else {
            PuginPageCallback.forEach((v, k) => {
                if (name_match(k)) v(page, datas);
            });
        }
    };

    const newUUID4 = () => {
        return "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx".replace(/[x]/g, c => {
            const r = Math.random() * 16 | 0;
            return r.toString(16);
        })
    };

    const im2png = async im => {
        const cv = document.createElement("canvas");
        const ctx = cv.getContext("2d");
        cv.width = im.width;
        cv.height = im.height;
        ctx.drawImage(im, 0, 0);
        return await new Promise(res => cv.toBlob(res));
    };

    const saveAsJson = () => {
        ChartUtils.optIdx();
        return JSON.stringify(config.chart, null, 4);
    };

    const doExport = async () => {
        const exportType = $("#top-bar-export-type-select").value;
        let exportRes;

        if (exportType === "json") {
            exportRes = saveAsJson();
        } else if (exportType === "js") {
            ChartUtils.optIdx();

            const statements = [
                "var m=MilizeBeatmap",
                "var t=m.timing",
                config.chart.storyboards.length ? "var s=m.storyboardObject" : "",
                "var n=m.note",
                "var a=m.animation",
                "var p=m.withProperty",
                "m.p=p",
                [
                    ["AudioFile", config.chart.meta.name + ".wav"],
                    ["BeatmapUID", newUUID4()],
                    ["Beatmapper", config.chart.meta.charter],
                    ["Composer", config.chart.meta.music_artist],
                    ["Difficulty", config.chart.meta.difficulty_name],
                    ["DifficultyValue", config.chart.meta.difficulty],
                    ["IllustrationFile", ""],
                    ["Illustrator", config.chart.meta.background_artist],
                    ["PreviewTime", -1.0],
                    ["Title", config.chart.meta.name],
                    ["UITheme", 0]
                ].map(x => `p(${JSON.stringify(x[0])},${JSON.stringify(x[1])})`).join("."),
            ];

            for (const bpm of config.chart.bpms) {
                statements.push(`t(${bpm.time.sec},${bpm.bpm},0)`);
            }

            statements.push(`for(let i=0;i<${config.chart.lines.length};i++){m.line()`);
            let firstcall = true;

            for (const sb of config.chart.storyboards) {
                statements.push(`${firstcall ? "}" : ""}s(${sb.type},${JSON.stringify(sb.data)},${sb.layer})`);
                firstcall = false;
            }

            for (const line of config.chart.lines) {
                for (const note of line.notes) {
                    statements.push(`${firstcall ? "}" : ""}n(${line.index},0,${note.time.sec.milsv},${note.endTime.sec.milsv},${note.type},${note.isFake.milsv},${note.isAlwaysPerfect.milsv})`);
                    firstcall = false;
                }
            }

            const push_e = e => {
                let sv = e.start;
                let tv = e.end;
                let cus = e.ease.cusValueExp;

                if (e.type === MIL_CES.EnumAnimationType.Rotation && e.bearer_type === MIL_CES.EnumAnimationBearerType.Line) {
                    sv = 180 - sv;
                    tv = 180 - tv;
                    if (e.ease.isValueExp) {
                        cus = `180 - (${cus})`;
                    }
                }

                statements.push(`a(0,${e.startTime.sec.milsv},${e.endTime.sec.milsv},${e.type},${sv.milsv_s},${tv.milsv_s},${e.bearer_type},${e.bearer},${e.ease.type},${e.ease.isValueExp ? 12 : e.ease.press},${e.ease.isValueExp.milsv},${JSON.stringify(cus)})`);
            }

            for (const line of config.chart.lines) {
                for (const e of line.animations) {
                    push_e(e);
                }
            }

            for (const sb of config.chart.storyboards) {
                for (const e of sb.animations) {
                    push_e(e);
                }
            }

            exportRes = statements.filter(x => !!x).join(";") + ";";
        } else if (exportType === "zip") {
            const zip = new JSZip();
            const meta = {
                chart_file: "chart.json",
                audio_file: `audio.${config.audioext}`,
                image_file: "image.png"
            };

            let created_sbf = false;
            let sbres_folder;
            let nores_sb = [];
            const saved_sbres = new Set();
            for (const sb of config.chart.storyboards) {
                if (sb.type !== MIL_CES.EnumStoryboardType.Picture) continue;
                if (saved_sbres.has(sb.data)) continue;
                if (!created_sbf) {
                    created_sbf = true;
                    sbres_folder = zip.folder("res");
                }

                // 谱师求你了别在名字里面加一堆稀奇古怪的字符让模拟器怎么活
                if (sb.data in config.storyboard_res) {
                    sbres_folder.file(sb.data, im2png(config.storyboard_res[sb.data]));
                } else {
                    nores_sb.push(sb.data);
                }
                saved_sbres.add(sb.data);
            }

            if (nores_sb.length) {
                let msg = `未找到以下Storyboard资源:\n${nores_sb.join("\n")}\n\n但导出仍会继续`;
                logger.warn(msg);
                alert(msg);
            }

            zip.file("chart.json", JSON.stringify(config.chart));
            zip.file(`audio.${config.audioext}`, await fetch(config.audio.src).then(r => r.arrayBuffer()));
            zip.file("image.png", im2png(config.illu));
            zip.file("meta.json", JSON.stringify(meta));
            exportRes = await zip.generateAsync({ type: "blob" });
        }

        logger.info(`导出为${exportType}`);

        const a = document.createElement("a");
        a.href = URL.createObjectURL(exportRes instanceof Blob ? exportRes : (new Blob([exportRes], { type: "text/plain" })));
        a.download = `${config.chart.meta.name}.${exportType}`;
        a.click();
    };

    const Utils = {
        rotate_point: (x, y, deg, l) => {
            const rad = deg * Math.PI / 180;
            return [
                x + l * Math.cos(rad),
                y + l * Math.sin(rad),
            ];
        },
        fixorp: p => Math.min(Math.max(p, 0.0), 1.0),
        int2rgba: n => {
            n = Math.floor(n);
            return [
                ((n >> 24) & 0xff) / 0xff,
                ((n >> 16) & 0xff) / 0xff,
                ((n >> 8) & 0xff) / 0xff,
                (n & 0xff) / 0xff,
            ];
        },
        ff_int2rgba: n => {
            n = Math.floor(n);
            return [
                (n >> 24) & 0xff,
                (n >> 16) & 0xff,
                (n >> 8) & 0xff,
                n & 0xff,
            ];
        },
        ff_rgba2int: arr => {
            return arr[0] << 24 | arr[1] << 16 | arr[2] << 8 | arr[3];
        },
        lineLength: (x0, y0, x1, y1) => Math.sqrt((x1 - x0) ** 2 + (y1 - y0) ** 2),
        filterKeys: (o, keys) => {
            const res = {};

            for (const k of keys) {
                res[k] = o[k];
            }

            return res;
        },
    };

    const ChartUtils = {
        beat2sec: t => {
            if (config.chart.bpms.length === 1) return t * 60 / config.chart.bpms[0].bpm;

            let sec = 0.0;

            for (const [i, e] of enumerate(config.chart.bpms)) {
                const spb = 60 / e.bpm;
                if (i !== config.chart.bpms.length - 1) {
                    const et_beat = config.chart.bpms[i + 1].time.value - e.time.value;

                    if (t >= et_beat) {
                        sec += et_beat * spb;
                        t -= et_beat;
                    } else {
                        sec += t * spb;
                        break;
                    }
                } else {
                    sec += t * spb;
                }
            }

            return sec;
        },
        sec2beat: t => {
            if (config.chart.bpms.length === 1) return t / 60 * config.chart.bpms[0].bpm;

            let beat = 0.0;

            for (const [i, e] of enumerate(config.chart.bpms)) {
                const spb = 60 / e.bpm;
                if (i !== config.chart.bpms.length - 1) {
                    const et_beat = config.chart.bpms[i + 1].time.value - e.time.value;
                    const et_sec = et_beat * spb;

                    if (t >= et_sec) {
                        beat += et_beat;
                        t -= et_sec;
                    } else {
                        beat += t / spb;
                        break;
                    }
                } else {
                    beat += t / spb;
                }
            }

            return beat;
        },
        get_bpm: t => {
            if (config.chart.bpms.length === 1) return config.chart.bpms[0].bpm;

            for (const [i, e] of enumerate(config.chart.bpms)) {
                if (i !== config.chart.bpms.length - 1) {
                    const et_beat = config.chart.bpms[i + 1].time.value - e.time.value;
                    const et_sec = et_beat * 60 / e.bpm;

                    if (t >= et_sec) t -= et_sec;
                    else return e.bpm;
                } else return e.bpm;
            }

            return -1.0;
        },
        time_range_beat2sec: (t1, t2) => {
            return ChartUtils.beat2sec(t2) - ChartUtils.beat2sec(t1);
        },

        get_es_value_filter_cache: new Map(),
        get_es_value: (es, t, deft, atype, filter) => {
            if (!es.length) return deft;
            const isColor = atype === MIL_CES.EnumAnimationType.Color;
            let res = deft;
            let found = false;

            const filterKey = `${atype},${filter.bearer_type},${filter.bearer}`;
            let filteredEs;
            if (ChartUtils.get_es_value_filter_cache.has(filterKey)) {
                filteredEs = ChartUtils.get_es_value_filter_cache.get(filterKey);
            } else {
                filteredEs = es.filter(e => e.type === atype && e.bearer_type === filter.bearer_type && e.bearer === filter.bearer);
                ChartUtils.get_es_value_filter_cache.set(filterKey, filteredEs);
            }

            if (!filteredEs.length) return deft;
            if (filteredEs[filteredEs.length - 1].endTime.value <= t) {
                res = filteredEs[filteredEs.length - 1].end;
                res = isColor ? Utils.int2rgba(res) : res;
                return res;
            } else if (filteredEs[0].startTime.value >= t) {
                res = filteredEs[0].startTime.value === filteredEs[0].endTime.value ? filteredEs[0].end : filteredEs[0].start;
                res = isColor ? Utils.int2rgba(res) : res;
                return res;
            }

            for (const e of filteredEs) {
                if (e.startTime.value >= t) {
                    if (!found) res = isColor ? Utils.int2rgba(e.start) : e.start;
                    break;
                } else if (e.endTime.value <= t) {
                    res = isColor ? Utils.int2rgba(e.end) : e.end;
                    found = true;
                } else if (e.startTime.value <= t && t <= e.endTime.value) {
                    let p = (t - e.startTime.value) / (e.endTime.value - e.startTime.value);

                    if (isColor) {
                        const startColor = Utils.int2rgba(e.start);
                        const endColor = Utils.int2rgba(e.end);

                        res = [
                            e.ease.doease(p, startColor[0], endColor[0]),
                            e.ease.doease(p, startColor[1], endColor[1]),
                            e.ease.doease(p, startColor[2], endColor[2]),
                            e.ease.doease(p, startColor[3], endColor[3]),
                        ];
                    } else {
                        res = e.ease.doease(p, e.start, e.end);
                    }

                    found = true;
                }
            }

            return res;
        },
        get_fp: (es, t, filter) => {
            let fp = 0.0;
            let laste = null;
            let firste = null;
            let is_break_end = false;
            let has_event = false;

            for (const e of es) {
                if (e.type !== MIL_CES.EnumAnimationType.Speed
                    || e.bearer_type !== filter.bearer_type
                    || e.bearer !== filter.bearer) continue;
                
                has_event = true;
                if (!firste) firste = e;
                if (laste) {
                    fp += ChartUtils.time_range_beat2sec(laste.endTime.value, Math.min(e.startTime.value, t)) * laste.end;
                }

                if (e.endTime.value <= t) fp += ChartUtils.time_range_beat2sec(e.startTime.value, e.endTime.value) * (e.start + e.end) / 2;
                else if (e.startTime.value <= t && t <= e.endTime.value) {
                    fp += ChartUtils.time_range_beat2sec(e.startTime.value, t) * (e.start + e.end) / 2;
                    is_break_end = true;
                    break;
                } else if (e.startTime.value > t) {
                    is_break_end = true;
                    break;
                }

                laste = e;
            }

            if (!has_event) return ChartUtils.time_range_beat2sec(0, t) * 1.0;

            if (firste) {
                fp += ChartUtils.time_range_beat2sec(0.0, Math.min(firste.startTime.value, t)) * (firste.startTime.value === firste.endTime.value ? firste.end : firste.start);
            }

            if (!is_break_end && laste) {
                fp += ChartUtils.time_range_beat2sec(laste.endTime.value, t) * laste.end;
            }

            return fp;

            // const nes = [];
            // for (const e of es) {
            //     if (e.type !== MIL_CES.EnumAnimationType.Speed
            //         || e.bearer_type !== filter.bearer_type
            //         || e.bearer !== filter.bearer) continue;

            //     if (nes.length === 0) {
            //         nes.push({
            //             st: 0.0, et: e.startTime.value,
            //             s: e.start, e: e.end
            //         });
            //     } else {
            //         const last = nes[nes.length - 1];
            //         if (last.et < e.startTime.value) {
            //             nes.push({
            //                 st: last.et, et: e.startTime.value,
            //                 s: last.e, e: last.e
            //             });
            //         }
            //     }

            //     nes.push({
            //         st: e.startTime.value, et: e.endTime.value,
            //         s: e.start, e: e.end
            //     });
            // }

            // if (!nes.length) return ChartUtils.time_range_beat2sec(0, t) * 1.0;

            // nes.push({
            //     st: nes[nes.length - 1].et, et: 1e9,
            //     s: nes[nes.length - 1].e, e: nes[nes.length - 1].e
            // })

            // let fp = 0.0
            // for (const e of nes) {
            //     if (e.st <= t && t <= e.et) fp += ChartUtils.time_range_beat2sec(e.st, t) * (e.s + e.e) / 2;
            //     else if (e.et < t) fp += ChartUtils.time_range_beat2sec(e.st, e.et) * (e.s + e.e) / 2;
            //     else break;
            // }

            // return fp;
        },

        normalize_to_screen: (x, y) => [
            x / MIL_SCRSIZE[0] + 0.5,
            1.0 - (y / MIL_SCRSIZE[1] + 0.5),
        ],
        normalize_to_center: (x, y) => [
            x / MIL_SCRSIZE[0],
            -y / MIL_SCRSIZE[1],
        ],
        normalized_to_cvs: (x, y, aw, ah) => [
            x * aw,
            y * ah
        ],

        get_note_position: (note, now_beat, fp, noteEventPos, noteRelPos, lineMergedPos, lineRotation) => {
            let notePos = [0, -fp];

            if (note.ishold && note.time.value <= now_beat) {
                notePos[1] = 0.0;
            }

            if (!isNaN(noteEventPos[0])) notePos[0] = noteEventPos[0];
            if (!isNaN(noteEventPos[1])) notePos[1] = noteEventPos[1];

            notePos[0] += noteRelPos[0];
            notePos[1] += noteRelPos[1];
            
            const transform = new WebCanvas2DTransform();
            transform.translate(...lineMergedPos);
            transform.rotateDegree(lineRotation - 90);

            return [notePos, transform];
        },

        lineFromIdx: idx => {
            for (const line of config.chart.lines) {
                if (line.index === idx) return line;
            }
            return null;
        },
        noteFromIdx: idx => {
            for (const line of config.chart.lines) {
                for (const note of line.notes) {
                    if (note.index === idx) return note;
                }
            }
            return null;
        },
        sbFromIdx: idx => {
            for (const sb of config.chart.storyboards) {
                if (sb.index === idx) return sb;
            }
            return null;
        },
        nextNoteIdx: () => {
            let maxidx = 0;
            for (const line of config.chart.lines) {
                for (const note of line.notes) {
                    if (note.index > maxidx) maxidx = note.index;
                }
            }
            return maxidx + 1;
        },
        nextLineIdx: () => {
            let maxidx = 0;
            for (const line of config.chart.lines) {
                if (line.index > maxidx) maxidx = line.index;
            }
            return maxidx + 1;
        },
        nextSbIdx: () => {
            let maxidx = 0;
            for (const sb of config.chart.storyboards) {
                if (sb.index > maxidx) maxidx = sb.index;
            }
            return maxidx + 1;
        },
        nextEventIdx: () => {
            let maxidx = 0;
            for (const line of config.chart.lines) {
                for (const e of line.animations) maxidx = Math.max(maxidx, e.index);
            }
            for (const sb of config.chart.storyboards) {
                for (const e of sb.animations) maxidx = Math.max(maxidx, e.index);
            }
            return maxidx + 1;
        },
        _optIdxUpdateMapping: (changedMap, dataMap) => {
            const newMap = new Map();
            dataMap.forEach((v, k) => {
                if (!changedMap.has(k)) newMap.set(k, v);
                else newMap.set(changedMap.get(k), v);
            });
            dataMap.clear();
            newMap.forEach((v, k) => dataMap.set(k, v));
        },
        optIdx: () => {
            const noteChangedMap = new Map();
            const eventChangedMap = new Map();
            const lineChangedMap = new Map();
            const sbChangedMap = new Map();

            const processed_events = [];
            const replace = (es, btype, o, n) => {
                for (const e of es) {
                    if (e.bearer_type === btype && e.bearer === o && !e.processed) {
                        e.bearer = n;
                        e.processed = true;
                        processed_events.push(e);
                    }
                }
            };

            let noteidx = 0;

            for (const [lineidx, line] of enumerate(config.chart.lines)) {
                replace(line.animations, MIL_CES.EnumAnimationBearerType.Line, line.index, lineidx);
                if (line.index !== lineidx) lineChangedMap.set(line.index, lineidx);
                line.index = lineidx;
                
                for (const note of line.notes) {
                    replace(line.animations, MIL_CES.EnumAnimationBearerType.Note, note.index, noteidx);
                    if (note.index !== noteidx) noteChangedMap.set(note.index, noteidx);
                    note.index = noteidx;
                    noteidx++;
                }
            }

            for (const [sbidx, sb] of enumerate(config.chart.storyboards)) {
                replace(sb.animations, MIL_CES.EnumAnimationBearerType.StoryBoard, sb.index, sbidx);
                if (sb.index !== sbidx) sbChangedMap.set(sb.index, sbidx);
                sb.index = sbidx;
            }

            processed_events.forEach(e => delete e.processed);

            let eidx = 0;

            for (const line of config.chart.lines) {
                for (const e of line.animations) {
                    if (e.index !== eidx) eventChangedMap.set(e.index, eidx);
                    e.index = eidx;
                    eidx++;
                }
            }

            for (const sb of config.chart.storyboards) {
                for (const e of sb.animations) {
                    if (e.index !== eidx) eventChangedMap.set(e.index, eidx);
                    e.index = eidx;
                    eidx++;
                }
            }

            ChartUtils._optIdxUpdateMapping(lineChangedMap, lines_pos);
            ChartUtils._optIdxUpdateMapping(eventChangedMap, editing_events_track_map);
            ChartUtils._optIdxUpdateMapping(noteChangedMap, config.morebets_cache);
        },
        lineFromNoteIdx: idx => {
            for (const line of config.chart.lines) {
                for (const note of line.notes) {
                    if (note.index === idx) return line;
                }
            }
            return null;
        },
        objFromEventIdx: idx => {
            for (const line of config.chart.lines) {
                for (const e of line.animations) {
                    if (e.index === idx) return e;
                }
            }
            for (const sb of config.chart.storyboards) {
                for (const e of sb.animations) {
                    if (e.index === idx) return e;
                }
            }
            return null;
        },
        eventFromIdx: idx => {
            for (const line of config.chart.lines) {
                for (const e of line.animations) {
                    if (e.index === idx) return e;
                }
            }
            for (const sb of config.chart.storyboards) {
                for (const e of sb.animations) {
                    if (e.index === idx) return e;
                }
            }
            return null;
        },
        getAllAnimations: () => {
            const allAnimations = [];
            for (const line of config.chart.lines) allAnimations.push(...line.animations);
            for (const sb of config.chart.storyboards) allAnimations.push(...sb.animations);
            return allAnimations;
        },
        objFromBearerData: data => {
            if (data.bearer_type === MIL_CES.EnumAnimationBearerType.Line) {
                return ChartUtils.lineFromIdx(data.bearer);
            } else if (data.bearer_type === MIL_CES.EnumAnimationBearerType.Note) {
                return ChartUtils.lineFromNoteIdx(data.bearer);
            } else if (data.bearer_type === MIL_CES.EnumAnimationBearerType.StoryBoard) {
                return ChartUtils.sbFromIdx(data.bearer);
            } else {
                // ?
            }
        }
    };

    const MIL_CES = {
        EnumAnimationType: {
            PositionX: 0,
            PositionY: 1,
            Transparency: 2,
            Size: 3,
            Rotation: 4,
            FlowSpeed: 5,
            RelativeX: 6,
            RelativeY: 7,
            LineBodyTransparency: 8,
            LineHeadTransparency: 9,
            StoryBoardWidth: 10,
            StoryBoardHeight: 11,
            Speed: 12,
            WholeTransparency: 13,
            StoryBoardLeftBottomX: 14,
            StoryBoardLeftBottomY: 15,
            StoryBoardRightBottomX: 16,
            StoryBoardRightBottomY: 17,
            StoryBoardLeftTopX: 18,
            StoryBoardLeftTopY: 19,
            StoryBoardRightTopX: 20,
            StoryBoardRightTopY: 21,
            Color: 22,
            VisibleArea: 23,
        },
        EnumAnimationTypeName: {
            0: "X坐标", 1: "Y坐标",
            2: "透明度", 3: "大小",
            4: "旋转", 5: "速度系数",
            6: "相对X", 7: "相对Y",
            8: "线体透明度", 9: "线头透明度",
            10: "故事板宽度", 11: "故事板高度",
            12: "速度", 13: "note整体透明度",
            14: "故事板左下X", 15: "故事板左下Y",
            16: "故事板右下X", 17: "故事板右下Y",
            18: "故事板左上X", 19: "故事板左上Y",
            20: "故事板右上X", 21: "故事板右上Y",
            22: "颜色", 23: "note可见区域",
        },
        EnumAnimationTypeNameShort: {
            0: "X", 1: "Y",
            2: "A", 3: "S",
            4: "R", 5: "FS",
            6: "RX", 7: "RY",
            8: "LBA", 9: "LHA",
            10: "SBW", 11: "SBH",
            12: "SP", 13: "NA",
            14: "SBLBX", 15: "SBLBY",
            16: "SBRBX", 17: "SBRBY",
            18: "SBUTX", 19: "SBUTY",
            20: "SBRUX", 21: "SBRUY",
            22: "C", 23: "VA"
        },
        EnumAnimationBearerType: {
            Line: 0,
            Note: 1,
            StoryBoard: 2,
        },
        EnumAnimationBearerTypeText: {
            0: "轨", 1: "键", 2: "故"
        },
        EnumAnimationBearerTypeTextLong: {
            0: "轨道", 1: "音符", 2: "故事板对象"
        },
        EnumStoryboardType: {
            Picture: 0,
            Text: 1,
            Mash: 2,
        },
        EnumStoryboardTypeName: {
            0: "图片", 1: "文字", 2: "棍母"
        },
        EnumLayer: {
            Background: 0,
            Normal: 1,
            Foreground: 2,
        },
        EnumStoryboardLayerName: {
            0: "背景",
            1: "默认",
            2: "前景"
        },
        EnumNoteType: {
            Hit: 0,
            Drag: 1,
        },
        EnumEaseTypeText: {
            0: "缓入",
            1: "缓出",
            2: "缓入缓出",
        },
        EnumEasePressText: {
            0: "Linear",
            1: "Sine",
            2: "Quad",
            3: "Cubic",
            4: "Quart",
            5: "Quint",
            6: "Expo",
            7: "Circ",
            8: "Back",
            9: "Elastic",
            10: "Bounce",
        }
    };

    const MIL_SCRSIZE = [1920, 1080];
    const MIL_LINE_HEAD_SIZE = 0.0223;
    const MIL_LINE_HEAD_BORDER = MIL_LINE_HEAD_SIZE * (18 / 186);
    const MIL_SPEED_UNIT = 108.0;
    const MIL_NOTE_SIZE = MIL_LINE_HEAD_SIZE;
    const MIL_HOLD_DISAPPEAR_TIME = 0.2;

    add_res_selector($("#res-selectors"), "音频文件", [".wav", ".mp3", ".ogg", ".flac"], "audio");
    add_res_selector($("#res-selectors"), "图片文件", [".png", ".jpg", ".jpeg", ".bmp"], "image");
    add_res_selector($("#res-selectors"), "谱面文件 (可选)", [".json"], "chart");
    add_res_selector($("#res-selectors"), "故事板资源 (可选)", null, "sbres", true);
    add_res_getter($("#res-selectors"), "进入编辑器", ["audio", "image", "chart", "sbres"], launch_editor);

    const edit_pages = [];
    const edit_pages_back_btns = [];

    $("#main").style.display = "none";

    const init_edit_page = element => {
        element.style.display = "none";
        edit_pages.push(element);
        const back_btn = document.createElement("div");
        back_btn.classList.add("milbtn");
        back_btn.innerHTML = "👈";
        back_btn.style.width = back_btn.style.height = "2em";
        element.back_btn = back_btn;
        edit_pages_back_btns.push(back_btn);
        element.querySelector("#edit-page-back-container").appendChild(back_btn);
    };

    $("#editor").childNodes.forEach(element => {
        if (element.nodeName !== "DIV") return;
        element.classList.add("editor-area-block");

        if (element.id.startsWith("edit-page-")) {
            init_edit_page(element);
        }
    });

    const init_rb_button = btn => {
        btn.classList.add("milbtn");
        btn.addEventListener("click", into_edit_page_event_handler);
    };

    $("#rb-button-pages-container").childNodes.forEach(element => {
        if (element.nodeName !== "DIV") return;
        element.id = "rb-buttons-page-item";

        element.childNodes.forEach(btn => {
            if (btn.nodeName !== "DIV") return;
            init_rb_button(btn);
        });
    });

    $("#editor-on-preview").addEventListener("wheel", e => {
        if (e.ctrlKey) e.preventDefault();

        if (!e.ctrlKey) {
            config.audio.currentTime -= 60 / ChartUtils.get_bpm(config.audio.currentTime) * e.deltaY / 100 * config.scroll_beat.divVal;
            logger.info(`${e.deltaY < 0 ? "前进" : "后退"} ${config.scroll_beat[0]}/${config.scroll_beat[1]} 拍`);
        } else if (e.ctrlKey &&
                   editing_note_lines_area[2] <= offsetX &&
                   offsetX <= editing_note_lines_area[3]) {
            const rawv = editing_note_dx;
            editing_note_dx += e.deltaY / 100 * w / 30;
            editing_note_dx = Math.max(0.0, editing_note_dx);
            if (boxingNote) {
                boxNoteStart[0] += rawv - editing_note_dx;
            }
            logger.info(`note编辑区域滚动: ${editing_note_dx}`);
        } else if (e.ctrlKey &&
                   editing_event_lines_area[0] <= offsetX &&
                   offsetX <= editing_event_lines_area[1]) {
            const rawv = editing_event_dx;
            editing_event_dx += e.deltaY / 100 * w / 30;
            editing_event_dx = Math.max(0.0, editing_event_dx);
            if (boxingEvent) {
                boxEventStart[0] += rawv - editing_event_dx;
            }
            logger.info(`event编辑区域滚动: ${editing_event_dx}`);
        }
    });
    
    var offsetX, offsetY;
    var selecting_note = null;
    var selecting_event = null;
    var moving_event_st = [0, 0, 1];
    const mousePosUpdater = e => {
        offsetX = e.clientX;
        offsetY = e.clientY - $("#editor-on-preview").offsetTop;
    };

    window.addEventListener("mousedown", mousePosUpdater);
    window.addEventListener("mousemove", mousePosUpdater);

    var boxingNote = false;
    var boxNoteStart = [-1, -1];
    var boxNoteEnd = [-1, -1];
    var boxingNoteIdxs = [];
    var boxingNoteMoving = false;
    var boxingNoteLastMove = [0, 0, 1];
    var boxingEvent = false;
    var boxEventStart = [-1, -1];
    var boxEventEnd = [-1, -1];
    var boxingEventIdxs = [];
    var boxingEventMoving = false;
    var boxingEventLastMove = [0, 0, 1];

    const clearEditingState = () => {
        boxingNote = false;
        boxingNoteIdxs.length = 0;
        boxingEvent = false;
        boxingEventIdxs.length = 0;
        editing_note = null;
        editing_event = null;
        $("#edit-page-note-edit").back_btn?.click();
        $("#edit-page-event-edit").back_btn?.click();
        $("#edit-page-batch-note-edit").back_btn?.click();
        $("#edit-page-batch-event-edit").back_btn?.click();
    };

    $("#editor-on-preview-inner").addEventListener("mousedown", e => {
        if (e.button === 2 &&
            editing_note_lines_area[0] <= offsetX &&
            offsetX <= editing_note_lines_area[1] &&
            editing_note_lines_area[2] <= offsetX &&
            offsetX <= editing_note_lines_area[3]) {
            const idx = parseInt(prompt("请输入要添加编辑note的线序号: "));
            if (!isNaN(idx) && ChartUtils.lineFromIdx(idx) !== null) {
                config.chart.editor.editing.note.push(idx);
            }
            return;
        }

        for (const [i, area] of enumerate(editing_note_lines_remove_areas)) {
            if (e.button === 2 &&
                area[0] <= offsetX &&
                offsetX <= area[0] + area[2] &&
                area[1] <= offsetY &&
                offsetY <= area[1] + area[3] &&
                editing_note_lines_area[2] <= offsetX &&
                offsetX <= editing_note_lines_area[3]) {
                config.chart.editor.editing.note.splice(i, 1);
                logger.info(`删除了序号为 ${i} 的 note 编辑`);
                return;
            }
        }

        for (const [i, [noteidx, area]] of enumerate(editing_note_lines_note_areas)) {
            if (e.button === 0 &&
                area[0] <= offsetX &&
                offsetX <= area[0] + area[2] &&
                area[1] <= offsetY &&
                offsetY <= area[1] + area[3] &&
                editing_note_lines_area[2] <= offsetX &&
                offsetX <= editing_note_lines_area[3] &&
                !e.ctrlKey && !boxingNote) {
                config.audio.pause();

                if (ChartUtils.noteFromIdx(noteidx) === null) {
                    logger.info(`序号为 ${noteidx} 的 note 不存在, 为什么啊为什么啊为什么啊为什么啊`);
                    return;
                }

                if (!boxingNoteIdxs.includes(noteidx)) {
                    clearEditingState(); // 不可以放到外面
                    into_edit_page($("#edit-page-note-edit"), {
                        noteidx: noteidx,
                    });
                    logger.info(`点击了序号为 ${noteidx} 的 note, 进入编辑`);
                    boxingNoteIdxs.length = 0;
                    selecting_note = noteidx;
                } else {
                    boxingNoteMoving = true;
                    boxingNoteLastMove = editing_note_lines_get_beat_from_y(offsetY);
                }

                return;
            }
        }

        for (const [i, [eidx, area]] of enumerate(editing_events_areas)) {
            if (e.button === 0 &&
                area[0] <= offsetX &&
                offsetX <= area[2] &&
                area[1] <= offsetY &&
                offsetY <= area[3]) {
                config.audio.pause();

                if (!boxingEventIdxs.includes(eidx)) {
                    clearEditingState(); // 不可以放到外面
                    editing_event = eidx;
                    into_edit_page($("#edit-page-event-edit"), {
                        eidx: eidx,
                    });
                    selecting_event = eidx;
                    moving_event_st = editing_note_lines_get_beat_from_y(offsetY);
                    logger.info(`点击了序号为 ${eidx} 的 event, 进入编辑`);
                } else {
                    boxingEventMoving = true;
                    boxingEventLastMove = editing_note_lines_get_beat_from_y(offsetY);
                }

                return;
            }
        }

        if (e.button === 0 &&
            editing_note_lines_area[2] <= offsetX &&
            offsetX <= editing_note_lines_area[3]) {
            clearEditingState();
            boxingNote = true;
            boxNoteStart = boxNoteEnd = [offsetX, offsetY];
            return;
        }

        if (e.button === 0 &&
            editing_event_lines_area[0] <= offsetX &&
            offsetX <= editing_event_lines_area[1]) {
            clearEditingState();
            boxingEvent = true;
            boxEventStart = boxEventEnd = [offsetX, offsetY];
            return;
        }

        clearEditingState();
    });

    $("#editor-on-preview").addEventListener("mousedown", e => {
        if (!display_eop) { // 这个不能放到 inner 里面, display_eop 为 false 的时候 inner 是 display none 的
            for (const [idx, poly] of notes_rects) {
                const inpoly = py_light_utils_exports.pointInPolygon([...poly, poly[0]], [offsetX, offsetY]);
                if (e.button === 0 && inpoly) {
                    config.audio.pause();
                    editing_note = idx;
                    into_edit_page($("#edit-page-note-edit"), {
                        noteidx: idx,
                    });
                    logger.info(`点击了序号为 ${idx} 的 note, 进入编辑`);
                    return;
                }
            }
        }
    });

    $("#editor-on-preview-inner").addEventListener("mousemove", e => {
        if (editing_note_lines_area[2] <= offsetX &&
            offsetX <= editing_note_lines_area[3] &&
            selecting_note !== null && !boxingNote && boxingNoteIdxs.length === 0) {
            const note = ChartUtils.noteFromIdx(selecting_note);
            const lidx = editing_note_lines_get_index_from_x(offsetX);
            const newline = ChartUtils.lineFromIdx(config.chart.editor.editing.note[lidx]);
            const beat = editing_note_lines_get_beat_from_y(offsetY);
            const rawline = ChartUtils.lineFromNoteIdx(selecting_note);
            if (newline === null) return;
            if (Math.abs(beat.value - note.time.value) <= FUCK && newline.index === rawline.index) return;
            const edt = note.endTime.value - note.time.value;
            note.time = beat;
            note.endTime = (beat.value + edt).tobeat;
            if (note.endTime.value < note.time.value) note.endTime = note.time;
            if (rawline.index !== newline.index) {
                rawline.notes = rawline.notes.filter(n => n.index !== selecting_note);
                newline.notes.push(note);
                newline.notes.sort((a, b) => a.time.value - b.time.value);
                ChartUtils.optIdx();
                selecting_note = note.index;
                editing_note = note.index;
                into_edit_page($("#edit-page-note-edit"), {
                    noteidx: note.index,
                });
            }
            logger.info(`移动了序号为 ${selecting_note} 的 note 到 ${beat.beatstr} ${note.endTime.beatstr} line=${lidx}`);
            onchartchanged(`移动了序号为 ${selecting_note} 的 note`);
            return;
        }

        if (editing_event_lines_area[0] <= offsetX &&
            offsetX <= editing_event_lines_area[1] &&
            selecting_event !== null && !boxingEvent && boxingEventIdxs.length === 0) {
            const e = ChartUtils.eventFromIdx(selecting_event);
            const newTime = editing_note_lines_get_beat_from_y(offsetY);
            if (newTime.value === moving_event_st.value) return;
            const moveDt = newTime.value - moving_event_st.value;
            const dt = e.endTime.value - e.startTime.value;
            e.startTime = (e.startTime.value + moveDt).tobeat;
            e.endTime = (e.startTime.value + dt).tobeat;
            logger.info(`移动了序号为 ${selecting_event} 的 event 到 ${newTime.beatstr}`);
            onchartchanged(`移动了序号为 ${selecting_event} 的 event`);
            moving_event_st = newTime;
            return;
        }

        if (boxingNote) {
            boxNoteEnd = [offsetX, offsetY];
        }

        if (boxingEvent) {
            boxEventEnd = [offsetX, offsetY];
        }
        
        if (boxingNoteMoving && e.button === 0) {
            const beat = editing_note_lines_get_beat_from_y(offsetY);
            if (beat.value === boxingNoteLastMove.value) return;

            const dt = beat.value - boxingNoteLastMove.value;
            for (const noteidx of boxingNoteIdxs) {
                const note = ChartUtils.noteFromIdx(noteidx);
                note.time = (note.time.value + dt).tobeat;
                note.endTime = (note.endTime.value + dt).tobeat;
            }
            logger.info(`批量移动了序号为${boxingNoteIdxs.join(",")}的note, dt=${dt}`);
            onchartchanged(`批量移动了序号为${boxingNoteIdxs.join(",")}的note`);

            boxingNoteLastMove = beat;
        }

        if (boxingEventMoving && e.button === 0) {
            const beat = editing_note_lines_get_beat_from_y(offsetY);
            if (beat.value === boxingEventLastMove.value) return;

            const dt = beat.value - boxingEventLastMove.value;
            for (const eventidx of boxingEventIdxs) {
                const event = ChartUtils.eventFromIdx(eventidx);
                event.startTime = (event.startTime.value + dt).tobeat;
                event.endTime = (event.endTime.value + dt).tobeat;
            }
            logger.info(`批量移动了序号为${boxingEventIdxs.join(",")}的event, dt=${dt}`);
            onchartchanged(`批量移动了序号为${boxingEventIdxs.join(",")}的event`);

            boxingEventLastMove = beat;
        }
    });

    $("#editor-on-preview-inner").addEventListener("mouseup", e => {
        if (e.button === 0) {
            selecting_note = null;
            selecting_event = null;
        }
        boxingNote = false;
        boxingNoteMoving = false;
        boxingEvent = false;
        boxingEventMoving = false;
    });

    var creating_note = null;
    var creating_event = null;
    window.addEventListener("keydown", e => {
        if (e.repeat) return;
        if (isInputActive(e)) return;
        if (["q", "w"].includes(e.key) &&
            editing_note_lines_area[2] <= offsetX &&
            offsetX <= editing_note_lines_area[3]) {
            const lineidx = config.chart.editor.editing.note[editing_note_lines_get_index_from_x(offsetX)];
            if (lineidx !== void 0) {
                const beat = editing_note_lines_get_beat_from_y(offsetY);
                const notetype = e.key === "q" ? MIL_CES.EnumNoteType.Hit : MIL_CES.EnumNoteType.Drag;
                const note = {
                    time: beat,
                    type: notetype,
                    isFake: false,
                    isAlwaysPerfect: false,
                    index: ChartUtils.nextNoteIdx(),
                    endTime: beat
                };
                creating_note = note;
                const line = ChartUtils.lineFromIdx(lineidx);

                line.notes.push(note);
                line.notes.sort((a, b) => a.time.value - b.time.value);
                
                editing_note = note.index;
                into_edit_page($("#edit-page-note-edit"), {
                    noteidx: note.index,
                });
                logger.info(`在序号为 ${lineidx} 的线上的 ${beat.beatstr} 处添加了 note ${JSON.stringify(note)}`);
                onchartchanged(`在序号为 ${lineidx} 的线上的 ${beat.beatstr} 处添加了 note`);
            }
        } else if (["q", "w", "e"].includes(e.key) &&
                   editing_event_lines_area[0] <= offsetX &&
                   offsetX <= editing_event_lines_area[1]) {
            const trackidx = editing_event_lines_get_index_from_x(offsetX);
            const track = edtracks[trackidx];
            if (!track) return;
            const sbeat = editing_note_lines_get_beat_from_y(offsetY);
            let new_event = {
                startTime: sbeat,
                endTime: sbeat,
                start: 0,
                end: 0,
                type: config.chart.editor.editing.new_event.type,
                bearer_type: ["q", "w", "e"].indexOf(e.key),
                bearer: config.chart.editor.editing.new_event.bearer,
                ease: {
                    type: 0,
                    press: 0,
                    isValueExp: false,
                    cusValueExp: "",
                    clipLeft: 0,
                    clipRight: 1,
                },
                index: ChartUtils.nextEventIdx(),
            };

            for (const e of ChartUtils.getAllAnimations()) {
                if (e.type === new_event.type && e.bearer_type === new_event.bearer_type && e.bearer === new_event.bearer) {
                    const ot = [e.startTime.value, e.endTime.value];
                    if (ot[0] + FUCK < sbeat.value - FUCK && sbeat.value + FUCK < ot[1] - FUCK) return;
                }
            }

            let inserted = false;
            for (const [i, e] of enumerate(track)) {
                const ot = [e.startTime.value, e.endTime.value];
                if (ot[0] + FUCK < sbeat.value - FUCK && sbeat.value + FUCK < ot[1] - FUCK) return;
                else if (ot[1] < sbeat.value) {
                    track.splice(i, 0, new_event);
                    inserted = true;
                    break;
                }
            }

            if (!inserted) track.splice(0, 0, new_event);
            editing_events_track_map.set(new_event.index, trackidx);

            const bearer_obj = ChartUtils.objFromBearerData(new_event);
            if (bearer_obj === null) return;
            bearer_obj.animations.push(new_event);
            bearer_obj.animations.sort((a, b) => a.startTime.value - b.startTime.value);

            if (config.chart.editor.editing.auto_attach_event) {
                for (const e of bearer_obj.animations) {
                    if (e.index !== new_event.index && e.bearer_type === new_event.bearer_type && e.bearer === new_event.bearer && e.type === new_event.type) {
                        if (e.endTime.value <= new_event.startTime.value) new_event.start = new_event.end = e.end;
                    }
                }
            }

            editing_event = new_event.index;
            creating_event = new_event;
            into_edit_page($("#edit-page-event-edit"), {
                eidx: new_event.index,
            });
            logger.info(`在序号为 ${trackidx} 的轨道上的 ${sbeat.beatstr} 处添加了 event ${JSON.stringify(new_event)}`);
            onchartchanged(`在序号为 ${trackidx} 的轨道上的 ${sbeat.beatstr} 处添加了 event`);
        }
    });

    window.addEventListener("mousemove", e => {
        if (creating_note !== null && creating_note.type === MIL_CES.EnumNoteType.Hit) {
            const endbeat = editing_note_lines_get_beat_from_y(offsetY);
            if (endbeat.value >= creating_note.time.value && endbeat.value !== creating_note.endTime.value) {
                creating_note.endTime = endbeat;
                logger.info(`将序号为 ${creating_note.index} 的 note 的结束时间设为 ${endbeat.beatstr}`);
                onchartchanged(`将序号为 ${creating_note.index} 的 note 的结束时间设为 ${endbeat.beatstr}`);
                into_edit_page($("#edit-page-note-edit"), {
                    noteidx: creating_note.index,
                });
            }
        } else if (creating_event !== null) {
            let endbeat = editing_note_lines_get_beat_from_y(offsetY);
            if (endbeat.value >= creating_event.startTime.value) {
                for (const e of ChartUtils.getAllAnimations()) {
                    if (e.type === creating_event.type && e.bearer_type === creating_event.bearer_type && e.bearer === creating_event.bearer && e.index !== creating_event.index) {
                        const ot = [e.startTime.value, e.endTime.value];
                        if (ot[0] - FUCK < endbeat.value && endbeat.value < ot[1] + FUCK) {
                            endbeat = e.startTime;
                            break;
                        }
                    }
                }
            } else {
                endbeat = creating_event.startTime;
            }
            creating_event.endTime = endbeat;
            logger.info(`将序号为 ${creating_event.index} 的 event 的结束时间设为 ${endbeat.beatstr}`);
            onchartchanged(`将序号为 ${creating_event.index} 的 event 的结束时间设为 ${endbeat.beatstr}`);
            into_edit_page($("#edit-page-event-edit"), {
                eidx: creating_event.index,
            });
        }
    });

    window.addEventListener("keyup", e => {
        if (e.key === "q") creating_note = null;
        if (creating_event !== null && ["q", "w", "e"].includes(e.key) && ["q", "w", "e"].indexOf(e.key) === creating_event.bearer_type) creating_event = null;
    });

    const isInputActive = e => {
        return e.target.tagName === "INPUT" || 
               e.target.tagName === "TEXTAREA" || 
               e.target.isContentEditable ||
               e.target.getAttribute("role") === "textbox";
    };
    
    window.addEventListener("keydown", e => {
        if (e.code !== "Space" || isInputActive(e)) return;
        
        config.audio.paused ? config.audio.play() : config.audio.pause();
        logger.info(`${!config.audio.paused ? "播放" : "暂停"}`);
    });

    window.addEventListener("keydown", e => {
        if (e.key !== "d" || e.repeat || isInputActive(e)) return;
        previewing = true;
        preview_back = e.ctrlKey;
        preview_backtime = config.audio.currentTime;

        if (preview_back && config.audio.paused) config.audio.play();
        logger.info("开始预览");
    });

    window.addEventListener("keyup", e => {
        if (e.key !== "d") return;
        previewing = false;

        if (preview_back) {
            config.audio.currentTime = preview_backtime;
            if (!config.audio.paused) config.audio.pause();
        }

        logger.info(`结束预览${preview_back ? "并回退到" + preview_backtime : ""}`);
    });

    Object.defineProperty(Array.prototype, "value", {
        get: function () {
            return this[0] + this[1] / this[2];
        },
        enumerable: false
    });

    Object.defineProperty(Array.prototype, "divVal", {
        get: function () {
            return this[0] / this[1];
        },
        enumerable: false
    });

    Object.defineProperty(Array.prototype, "sec", {
        get: function () {
            return ChartUtils.beat2sec(this.value);
        },
        enumerable: false
    });

    Object.defineProperty(Object.prototype, "ishold", {
        get: function() {
            return this.type === MIL_CES.EnumNoteType.Hit && this.endTime.value - this.time.value > 0.0;
        },
        enumerable: false
    });

    Object.defineProperty(Object.prototype, "resname", {
        get: function() {
            return `${this.type === MIL_CES.EnumNoteType.Hit && this.isAlwaysPerfect ? "ex" : ""}${this.type === MIL_CES.EnumNoteType.Hit ? (this.ishold ? "hold" : "tap") : "drag"}${this.morebets ? "_double" : ""}`;
        },
        enumerable: false
    });

    Object.defineProperty(Object.prototype, "morebets", {
        get: function() {
            if (config.morebets_cache.has(this.index)) return config.morebets_cache.get(this.index);
            for (const line of config.chart.lines) {
                for (const note of line.notes) {
                    if (note.index !== this.index && note.time.value === this.time.value) {
                        config.morebets_cache.set(this.index, true);
                        return true;
                    }
                }
            }
            config.morebets_cache.set(this.index, false);
            return false;
        },
        enumerable: false
    });

    Object.defineProperty(Object.prototype, "beatstr", {
        get: function() {
            return `${this[0]}:${this[1]}/${this[2]}`;
        },
        enumerable: false
    });

    Object.defineProperty(Number.prototype, "milsv", {
        get: function() {
            return this.toFixed(5);
        },
        enumerable: false
    });

    Object.defineProperty(Number.prototype, "milsv_s", {
        get: function() {
            return `"${this.toFixed(5)}"`;
        },
        enumerable: false
    });

    Object.defineProperty(Boolean.prototype, "milsv", {
        get: function() {
            return this ? "!0" : "!1";
        },
        enumerable: false
    });

    Object.defineProperty(Number.prototype, "tobeat", {
        get: function() {
            if (isNaN(this)) return null;
            if (!isFinite(this)) return null;

            const limit = 64;
            const a = Math.floor(this);
            const dv = this - a;
            const s = 1000000;
            
            let [p0, q0, p1, q1] = [0, 1, 1, 0];
            let [n, d] = [Math.floor(dv * s), s];
            while (true) {
                b = Math.floor(n / d);
                const q2 = q0 + b * q1;
                if (q2 > limit) break;
                [p0, q0, p1, q1] = [p1, q1, b * p1 + p0, q2];
                [n, d] = [d, n - b * d];
            }
            k = Math.floor((limit - q0) / q1);
            if ((2 * d * (q1 + k * q1)) <= limit) return [a, p1, q1];
            else return [a, p0 + k * p1, q0 + k * q1];
        },
        enumerable: false
    });

    Object.defineProperty(Object.prototype, "doease", {
        value: function(p, s, e) {
            const o = this;
            const cl = this.clipLeft;
            const cr = this.clipRight;
            let ef = this.isValueExp ?
                    (t => { with (Math) { return eval(o.cusValueExp); } }) :
                    (t => s + (e - s) * (easing_funcs[o.type][o.press] || (t => t))(t));

            if (cl !== 0.0 || cr !== 1.0) {
                const cs = ef(cl);
                const ce = ef(cr);
                const ref = ef;
                ef = ce !== cs ? (t => ((ref(t * (cr - cl) + cl) - cs) / (ce - cs))) : (t => t);
                return s + (e - s) * ef(p);
            } else return ef(p);
        },
        enumerable: false
    });

    Object.defineProperty(Array.prototype, "sortbykey", {
        value: function(key) {
            this.sort((a, b) => key(a) - key(b));
        },
        enumerable: false
    });

    Object.defineProperty(Object.prototype, "deepcopy", {
        value: function() {
            return JSON.parse(JSON.stringify(this));
        },
        enumerable: false
    });

    Object.defineProperty(Array.prototype, "sorted", {
        value: function() {
            const res = this.deepcopy();
            res.sort((a, b) => a - b);
            return res;
        },
        enumerable: false
    });

    const loadScript = async function(url) {
        let script = document.createElement("script");
        await new Promise((resolve, reject) => {
            script.src = url;
            document.head.appendChild(script);
            script.onerror = reject;
            script.onload = resolve;
        });
    };

    const loadCss = async function(url) {
        let link = document.createElement("link");
        await new Promise((resolve, reject) => {
            link.href = url;
            link.rel = "stylesheet";
            document.head.appendChild(link);
            link.onerror = reject;
            link.onload = resolve;
        });
    };

    const monaco_editor = "./resources/monaco-editor-uncompressed";
    var require = {
        "paths": { "vs": monaco_editor },
        "vs/nls": { "availableLanguages": { "*": "zh-cn" } }
    };

    window.addEventListener("beforeunload", e => {
        if (!pyleaving) e.preventDefault()
    });

    const createObjectURLHooks = new Set();
    URL._createObjectURL = URL.createObjectURL;
    URL.createObjectURL = function (x) {
        return !createObjectURLHooks.has(x) ? URL._createObjectURL(x) : x.url;
    };
    URL.createFileURL = async function (x) {
        const content = await fetch(`/api/readFile/${x}`).then(r => r.blob());
        x = {
            url: URL.createObjectURL(content),
            name: x
        };
        createObjectURLHooks.add(x);
        return x;
    };

    $("#back-home").style.display = "none";
    $("#save").style.display = "none";
    $("#auto-backup-label").style.display = "none";
    $("#top-bar-auto-backup-checkbox").style.display = "none";

    const loadEditor = async meta => { // webview 调的
        const o = {
            chart: await URL.createFileURL(meta.chartPath),
            audio: await URL.createFileURL(meta.audioPath),
            image: await URL.createFileURL(meta.imagePath),
            sbres: {}
        };

        const resFiles = await fetch(`/api/getFiles/${meta.sbresPath}`).then(r => r.json());
        for (const file of resFiles) {
            o.sbres[file] = await URL.createFileURL(meta.sbresPath + "/" + file);
        }

        $("#res-selectors").getres = () => o;

        $("#back-home").style.display = "inline-flex";
        $("#save").style.display = "inline-flex";
        $("#auto-backup-label").style.display = "inline";
        $("#top-bar-auto-backup-checkbox").style.display = "inline";
        $("#top-bar-auto-backup-checkbox").checked = true;

        $("#back-home").onclick = () => window.pywebview.api.backHome();
        $("#save").onclick = () => window.pywebview.api.doSave();

        window.addEventListener("keydown", e => {
            if (isInputActive(e) || !e.ctrlKey || e.key !== "s" || e.repeat) return;
            window.pywebview.api.doSave();
        });

        launch_editor();
    };

    window.addEventListener("keydown", e => {
        if (isInputActive(e) || e.code !== "Delete" || e.repeat) return;
        onDelete();
    });

    window.addEventListener("keydown", e => {
        if (isInputActive(e) || e.key !== "c" || !e.ctrlKey || e.repeat) return;
        doCopyEditing();
    });

    window.addEventListener("keydown", e => {
        if (isInputActive(e) || e.key !== "v" || !e.ctrlKey || e.repeat) return;
        doPasteEditing();
    });

    window.addEventListener("keydown", e => {
        return;
        if (isInputActive(e) || e.key !== "x" || !e.ctrlKey || e.repeat) return;
        doCopyEditing();
        doPasteEditing();
        disableDeleteWarn = true;
        onDelete();
        disableDeleteWarn = false;
    });

    window.addEventListener("wheel", e =>  {
        if (e.ctrlKey) e.preventDefault();
    });
</script>
